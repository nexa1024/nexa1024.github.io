---
title: DSA-Day02-49.字母异位词分组
date: 2026-1-16 00:00:00
categories: 数据结构与算法
---

## 题目概述
**哈希表 + 排序综合应用**。本题是 LeetCode 中等难度题，核心考点是**使用哈希表将排序后的字符串作为 key 进行分组**，是字符串处理的经典题目。

## 为什么这道题重要
这是 **哈希表分组**的典型应用，掌握后可解决：
- [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)（本题）
- [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)
- [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 暴力枚举 | O(n² × k) | O(nk) | 每组两两比较，性能差 |
| **排序 + HashMap** | **O(nk log k)** | **O(nk)** | **最优解，推荐背诵** |
| 计数 + HashMap | O(n(k+Σ)) | O(n(k+Σ)) | 字符集有限时较优 |

**背诵重点**：排序 + HashMap 解法（通用性强）

<!--more-->

## 题目
![](/images/algos/Day02-49.Group_Anagrams/01.png)

## 标签
数组、哈希表、字符串、排序

## 背诵模型
**模型/状态**

+ 我用一个**HashMap**记录strs中每个字符串排序后的结果作为key，数组作为value

**不变量/约束**

+ 遍历strs到i的位置，HashMap的key包含[0, i-1]这个区间的排序好的元素，value则是存入数组

**推进/转移**

+ 找到对应排序好的key，将当前元素push进数组

**终止/答案+边界**

+ 终止：
    - 终止：
        - 循环结束
    - 边界：
        - 单个元素
        - 空数组

**复杂度**

+ 时间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26。需要遍历 n 个字符串，对于每个字符串，需要 O(k) 的时间计算每个字母出现的次数，O(∣Σ∣) 的时间生成哈希表的键，以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(n(k+∣Σ∣))。

+ 空间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 O(∣Σ∣)，在渐进意义下小于 O(n(k+∣Σ∣))，可以忽略不计。

**常见坑**
+ 无




## 代码

### kotlin - 排序 + HashMap 解法
```plain
class Solution {
    fun groupAnagrams(strs: Array<String>): List<List<String>> {
        val map = hashMapOf<String, MutableList<String>>()

        for (str:String in strs) {
            // strs每个字符串内容重新排序作为key
            val key = str.toCharArray().sorted().joinToString("");
            val values = map.getOrDefault(key, mutableListOf())
            values.add(str)
            map.put(key, values)
        }
        return map.values.toList()
    }
}
```

### java - 排序 + HashMap 解法
```plain
import java.util.*;

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();

        for (String str : strs) {
            // 将字符串字符排序作为key
            char[] charArray = str.toCharArray();
            Arrays.sort(charArray);
            String key = new String(charArray);

            // 获取或创建对应key的列表
            List<String> list = map.getOrDefault(key, new ArrayList<>());
            list.add(str);
            map.put(key, list);
        }

        return new ArrayList<>(map.values());
    }
}
```

