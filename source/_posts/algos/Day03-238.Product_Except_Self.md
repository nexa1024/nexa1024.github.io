---
title: DSA-Day03-238.除自身以外数组的乘积
date: 2026-1-18 01:00:00
categories: 数据结构与算法
---

## 题目概述
**前缀积与后缀积的经典应用**。本题是 LeetCode 中等难度题，核心考点是**在不使用除法的情况下，计算除自身以外的数组乘积**，要求 O(n) 时间复杂度和 O(1) 额外空间（输出数组除外）。

## 为什么这道题重要
这是 **前缀和/前缀积思想**的典范，掌握后可解决：
- [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)（本题）
- [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
- [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

关键在于**将问题分解为前缀积和后缀积两部分**，避免了除法的使用（除法会遇到 0 的特殊情况）。

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 暴力枚举 | O(n²) | O(1) | 对每个位置计算其他元素乘积，性能差 |
| 左右乘积列表 | O(n) | O(n) | 用两个数组分别存储前缀和后缀积 |
| **输出数组复用（最优）** | **O(n)** | **O(1)** | **用输出数组存前缀，变量存后缀** |

**背诵重点**：输出数组复用解法（满足 O(1) 额外空间）

<!--more-->

## 题目
![](/images/algos/Day03-238.Product_Except_Self/01.png)

## 标签
数组、前缀和

## 背诵模型
**模型/状态**

+ 我用**answer 数组**先存储每个位置**左侧所有元素的乘积**（前缀积），再用一个**变量 R** 记录**右侧所有元素的乘积**（后缀积）

**不变量/约束**

+ 第一次遍历（左到右）：
    - answer[i] 存储的是 nums[0] × nums[1] × ... × nums[i-1]
    - answer[0] = 1（左边没有元素）
+ 第二次遍历（右到左）：
    - R 记录当前位置右侧所有元素的乘积
    - answer[i] = answer[i] × R（左侧乘积 × 右侧乘积）
    - R = R × nums[i]（更新后缀积）

**推进/转移**

+ 第一次遍历（计算前缀积）：
    - answer[i] = answer[i-1] × nums[i-1]
+ 第二次遍历（计算后缀积并更新答案）：
    - R 初始化为 1
    - answer[i] = answer[i] × R
    - R = R × nums[i]

**终止/答案+边界**

+ 终止：
    - 两次遍历完成
+ 边界：
    - 首元素：前缀积为 1，只有后缀积
    - 末元素：后缀积为 1，只有前缀积
    - 数组长度为 2：每个位置的乘积就是对方元素

**复杂度**

+ 时间复杂度：O(n)，其中 n 是数组长度。需要遍历数组两次，第一次计算前缀积，第二次计算后缀积并更新答案，因此总时间复杂度是 O(n)。

+ 空间复杂度：O(1)，除了输出数组外，只使用了常数个额外变量（R）。题目说明输出数组不算额外空间。

**常见坑**

+ 不能使用除法！遇到 0 会导致除零错误或逻辑错误
+ 第一次遍历时 answer[0] = 1（左边没有元素）
+ 第二次遍历从右向左，R 初始化为 1（右边没有元素）
+ 注意更新 R 的顺序：先使用 R 更新 answer[i]，再更新 R = R × nums[i]




## 代码

### kotlin - 输出数组复用解法（O(n) 时间，O(1) 空间）
```plain
class Solution {
    fun productExceptSelf(nums: IntArray): IntArray {
        val n = nums.size
        val answer = IntArray(n)

        // 1. 计算前缀积（左侧所有元素的乘积）
        answer[0] = 1
        for (i in 1 until n) {
            answer[i] = answer[i - 1] * nums[i - 1]
        }

        // 2. 计算后缀积（右侧所有元素的乘积）并更新答案
        var R = 1
        for (i in n - 1 downTo 0) {
            answer[i] = answer[i] * R
            R *= nums[i]
        }

        return answer
    }
}
```

### java - 输出数组复用解法（O(n) 时间，O(1) 空间）
```plain
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] answer = new int[n];

        // 1. 计算前缀积（左侧所有元素的乘积）
        answer[0] = 1;
        for (int i = 1; i < n; i++) {
            answer[i] = answer[i - 1] * nums[i - 1];
        }

        // 2. 计算后缀积（右侧所有元素的乘积）并更新答案
        int R = 1;
        for (int i = n - 1; i >= 0; i--) {
            answer[i] = answer[i] * R;
            R *= nums[i];
        }

        return answer;
    }
}
```
