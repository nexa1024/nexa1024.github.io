---
title: DSA-Day01-242.有效的字母异位词
date: 2026-1-15 00:00:00
categories: 数据结构与算法
---

## 题目概述
**哈希表字符计数**。本题是 LeetCode 简单题，核心考点是**使用哈希表统计字符频率判断两个字符串是否为字母异位词**。

## 为什么这道题重要
这是 **字符统计**的基础操作，掌握后可解决：
- [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)（本题）
- [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
- [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 排序后比较 | O(n log n) | O(1) 或 O(n) | 需要排序，代码简洁但性能较差 |
| **哈希表计数** | **O(n)** | **O(Σ)** | **最优解，Σ 为字符集大小** |
| 数组计数（限定小写字母） | O(n) | O(1) | 仅当字符集已知时可用 |

**背诵重点**：哈希表计数解法（O(n) 时间）

<!--more-->

## 题目
<!-- 这是一张图片，ocr 内容为： -->
![](/images/algos/Day01-242.Valid_Anagram/01.png)

## 标签
字符串、哈希、排序

## 背诵模型
**模型/状态**

+ 用一个**HashMap<Character, Integer>**记录**s**中每个字符的出现次数，key为字符，value为频率
+ 检查**s**和**t**长度，不等则直接返回 false
+ 遍历**s**建立频率表：所有字符作为key存入HashMap，对应value为其出现次数（都≥1）

**核心不变量**

+ 如果s和t互为字母异位词，遍历完t后，HashMap中所有value应该**恰好等于0**
+ 验证过程中，value永远不会小于0（在减到0之前就会被检测并返回false）

**推进/转移**

遍历**t**中的每个字符c：
1. 检查c是否在HashMap的key中 → 若不存在，返回false
2. 获取c的当前计数count
3. 检查count是否为0 → 若为0，返回false（说明t中c出现次数超过s）
4. 执行`frequencyMap.put(c, count - 1)`

**终止/答案+边界**

+ 返回false的情况：
    - **初始检查**：t和s的长度不一致
    - **验证过程**：t的字符在HashMap的key中无法找到
    - **验证过程**：t的字符在HashMap中的当前count已经为0（t中该字符出现次数超过s）
+ 返回true：正常遍历完t的所有字符

**复杂度**

+ 时间复杂度：O(n)，其中 n 为 s 的长度。
+ 空间复杂度：O(S)，其中 S 为字符集大小

**常见坑**
+ 无




## 代码
### java
```plain
class Solution {
    public boolean isAnagram(String s, String t) {

        if (s.length() != t.length()) return false;

        HashMap<Character, Integer> frequencyMap = new HashMap<>();
        for (char c: s.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        for(char c: t.toCharArray()) {
            if (!frequencyMap.containsKey(c)) return false;
            int count = frequencyMap.get(c);
            if (count == 0) { // 若t中字符出现次数超过s，返回false
                return false;
            }
            frequencyMap.put(c, count - 1);
        }

        return true;
    }
}
```

### kotlin
```plain
class Solution {
    fun isAnagram(s: String, t: String): Boolean {
        if (s.length != t.length) return false
        
        val frequencyMap = mutableMapOf<Char, Int>()
        for (c in s) {
            frequencyMap[c] = frequencyMap.getOrDefault(c, 0) + 1
        }
        for (c in t) {
            if (!frequencyMap.containsKey(c)) return false
            val count = frequencyMap[c]!!  // 安全获取（因已检查存在性）
            if (count == 0) return false
            frequencyMap[c] = count - 1
        }
        return true
    }
}
```

