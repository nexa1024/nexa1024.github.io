---
title: DSA-Day01-242.有效的字母异位词背诵模板
date: 2026-1-15 00:00:00
categories: 数据结构与算法
---

## 题目概述
**哈希表字符计数**。本题是 LeetCode 简单题，核心考点是**使用哈希表统计字符频率判断两个字符串是否为字母异位词**。

## 为什么这道题重要
这是 **字符统计**的基础操作，掌握后可解决：
- [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)（本题）
- [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
- [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 排序后比较 | O(n log n) | O(1) 或 O(n) | 需要排序，代码简洁但性能较差 |
| **哈希表计数** | **O(n)** | **O(Σ)** | **最优解，Σ 为字符集大小** |
| 数组计数（限定小写字母） | O(n) | O(1) | 仅当字符集已知时可用 |

**背诵重点**：哈希表计数解法（O(n) 时间）

<!--more-->

## 题目
<!-- 这是一张图片，ocr 内容为： -->
![](/images/algos/Day01-242.Valid_Anagram/01.png)

## 标签
字符串、哈希、排序

## 背诵模型
**模型/状态**

+ 我用一个**HashMap**记录**s**的所有字符出现的次数，key为字符，value为次数

**不变量/约束**

+ 遍历 **s **到 **i **的位置，**i-1**的字符在**HashMap**都作为了**key**，并且所有**value**都是**大于0**。

**推进/转移**

+ 循环**t**中的字符，找到**HashMap**中对应的**key，**如果找到则**value--**

**终止/答案+边界**

+ 终止：
    - **t**和**s**的长度不一致
    - **t**的字符在**HashMap**的**key**中无法找到。
    - **t**的字符在**HashMap**的**value**在**-1**之前已经为**0**

**复杂度**

+ 时间复杂度：O(n)，其中 n 为 s 的长度。
+ 空间复杂度：O(S)，其中 S 为字符集大小

**常见坑**
+ 无




## 代码
### java
```plain
class Solution {
    public boolean isAnagram(String s, String t) {

        if (s.length() != t.length()) return false;

        HashMap<Character, Integer> frequencyMap = new HashMap<>();
        for (char c: s.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        for(char c: t.toCharArray()) {
            if (!frequencyMap.containsKey(c)) return false;
            int count = frequencyMap.get(c);
            if (count == 0) { // 若t中字符出现次数超过s，返回false
                return false;
            }
            frequencyMap.put(c, count - 1);
        }

        return true;
    }
}
```

### kotlin
```plain
class Solution {
    fun isAnagram(s: String, t: String): Boolean {
        if (s.length != t.length) return false
        
        val frequencyMap = mutableMapOf<Char, Int>()
        for (c in s) {
            frequencyMap[c] = frequencyMap.getOrDefault(c, 0) + 1
        }
        for (c in t) {
            if (!frequencyMap.containsKey(c)) return false
            val count = frequencyMap[c]!!  // 安全获取（因已检查存在性）
            if (count == 0) return false
            frequencyMap[c] = count - 1
        }
        return true
    }
}
```

