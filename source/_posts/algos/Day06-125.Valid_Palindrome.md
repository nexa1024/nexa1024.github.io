---
title: DSA-Day06-125.验证回文串
date: 2026-02-14 00:00:00
categories: 数据结构与算法
---

## 题目概述
**双指针字符串处理**。本题是 LeetCode 简单题，核心考点是**使用双指针从字符串两端向中间遍历，跳过非字母数字字符并验证回文**，是字符串处理的典型应用。

## 为什么这道题重要
这是 **双指针思想** 在字符串处理中的入门应用，掌握后可解决：
- [125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)（本题）
- [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)
- [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

关键在于**理解双指针的相向移动模式**，以及如何优雅地处理字符过滤和大小写转换。

### 解法延伸路径
- **双指针基础（本题）** → 延伸至：[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)（双指针同向移动）
- **双指针进阶** → 延伸至：[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)、[15. 三数之和](https://leetcode.cn/problems/3sum/)（双指针在排序数组中的应用）

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 字符串重建 + 反转比较 | O(n) | O(n) | 先过滤再比较，需要额外空间 |
| **双指针原地比较** | **O(n)** | **O(1)** | **最优解，无需额外空间** |
| 递归 | O(n) | O(n) | 递归栈空间，不推荐 |

**背诵重点**：双指针原地比较解法（O(n) 时间，O(1) 空间）

<!--more-->

## 题目
如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串**。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串**，返回 `true`；否则，返回 `false`。

**示例 1：**
```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**示例 2：**
```
输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。
```

**示例 3：**
```
输入：s = " "
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 ""。
由于空字符串正着反着读都一样，所以是回文串。
```

**提示：**
- `1 <= s.length <= 2 * 10^5`
- `s` 仅由可打印的 ASCII 字符组成

## 标签
双指针、字符串

## 背诵模型
**模型/状态**

+ 使用**两个指针 left 和 right**：
  - left 从字符串开头向右移动
  - right 从字符串末尾向左移动
+ **统一转为小写**进行比较（或统一转为大写）

**不变量/约束**

+ left 始终小于等于 right（未相遇或未交叉）
+ 只有当 left 和 right 指向的字符都是字母或数字时才进行比较

**推进/转移**

+ left 指针移动：
  - 若 s[left] 不是字母或数字，left 右移（left++）
  - 否则停止
+ right 指针移动：
  - 若 s[right] 不是字母或数字，right 左移（right--）
  - 否则停止
+ 当两个指针都指向有效字符时：
  - 统一转为小写比较：`Character.toLowerCase(s[left]) != Character.toLowerCase(s[right])`
  - 若不相等，返回 false
  - 若相等，left 右移，right 左移继续比较

**终止/答案+边界**

+ 返回 false：发现不相等的字符对
+ 返回 true：left >= right（所有字符对都匹配）
+ 边界：
  - 空字符串：直接返回 true
  - 单字符：left = right，返回 true
  - 全为非字母数字字符：left 和 right 会相遇，返回 true

**复杂度**

+ 时间复杂度：O(n)，其中 n 是字符串长度。每个字符最多被访问一次。
+ 空间复杂度：O(1)，只使用了常数个额外变量（left 和 right 指针）。

**常见坑**

+ 必须统一大小写后再比较（不能直接比较 'A' 和 'a'）
+ 字符判断要用 `Character.isLetterOrDigit()` 而非自己写判断（处理 Unicode）
+ 指针移动时先跳过非字母数字字符，再进行比较
+ 注意循环条件是 `left < right`（不是 `left <= right`，避免重复比较中间字符）



## 代码
### java
```plain
class Solution {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;

        while (left < right) {
            // 跳过非字母数字字符（左指针）
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            // 跳过非字母数字字符（右指针）
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }

            // 比较字符（统一转为小写）
            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
                return false;
            }

            // 移动指针继续比较
            left++;
            right--;
        }

        return true;
    }
}
```

### kotlin
```plain
class Solution {
    fun isPalindrome(s: String): Boolean {
        var left = 0
        var right = s.length - 1

        while (left < right) {
            // 跳过非字母数字字符（左指针）
            while (left < right && !s[left].isLetterOrDigit()) {
                left++
            }
            // 跳过非字母数字字符（右指针）
            while (left < right && !s[right].isLetterOrDigit()) {
                right--
            }

            // 比较字符（统一转为小写）
            if (s[left].lowercaseChar() != s[right].lowercaseChar()) {
                return false
            }

            // 移动指针继续比较
            left++
            right--
        }

        return true
    }
}
```
