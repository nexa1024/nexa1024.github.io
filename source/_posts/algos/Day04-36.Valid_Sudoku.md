---
title: DSA-Day04-36.有效的数独
date: 2026-1-21 00:00:00
categories: 数据结构与算法
---

## 题目概述
**哈希表多维验证**。本题是 LeetCode 中等题，核心考点是**使用哈希表同时验证行、列、宫格三个维度的数字唯一性**，是空间换时间的典型应用。

## 为什么这道题重要
这是 **多维约束验证** 的经典问题，掌握后可理解：
- 如何同时处理多个维度的约束条件
- 二维坐标到一维索引的映射技巧
- 位运算在哈希表中的应用（空间优化）

### 延伸应用
- 位运算优化思想 → 延伸至：[338. 比特位计数](https://leetcode.cn/problems/counting-bits/)、[78. 子集](https://leetcode.cn/problems/subsets/)
- 多维验证思想 → 延伸至：[37. 解数独](https://leetcode.cn/problems/sudoku-solver/)（本题的进阶版）

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 暴力三次遍历 | O(9²) × 3 | O(1) | 需要遍历三次，代码冗余 |
| **哈希表一次遍历** | **O(9²)** | **O(9²)** | **最优解，一次遍历同时验证三维** |
| 位运算优化 | O(9²) | O(9) | 空间进一步优化 |

**背诵重点**：哈希表一次遍历解法（数组版本）

⚠️ **注意**：由于数独大小固定为 9×9，时间复杂度实际为 O(1)

<!--more-->

## 题目
![](/images/algos/Day04-36.Valid_Sudoku/01.png)
![](/images/algos/Day04-36.Valid_Sudoku/02.png)

## 标签
数组、哈希表、矩阵

## 背诵模型
**模型/状态**

+ 使用三个二维数组：
  - `row[9][9]`：row[i][num] 表示第 i 行是否已有数字 num
  - `col[9][9]`：col[j][num] 表示第 j 列是否已有数字 num
  - `box[9][9]`：box[k][num] 表示第 k 个宫格是否已有数字 num
+ 遍历到坐标 (i, j) 时：
  - 若为空格 '.'，跳过
  - 若为数字 d（1-9），转换为索引 num = d - '1'（0-8）

**不变量/约束**

+ 三个数组分别维护行、列、宫格的数字出现状态
+ 任何数字在同一行、同一列、同一宫格内只能出现一次

**推进/转移**

+ 对于非空格数字：
  1. 计算宫格索引：`boxIndex = (i / 3) * 3 + (j / 3)`
  2. 检查冲突：`row[i][num]`、`col[j][num]`、`box[boxIndex][num]` 任一为 true 则冲突
  3. 若无冲突，标记该数字：将三个对应位置都置为 true

**宫格索引计算详解**

+ 9×9 数独被分成 9 个 3×3 宫格，编号为 0-8：
  ```
  宫格 0 | 宫格 1 | 宫格 2
  ------|--------|------
  宫格 3 | 宫格 4 | 宫格 5
  ------|--------|------
  宫格 6 | 宫格 7 | 宫格 8
  ```
+ 公式 `(i / 3) * 3 + (j / 3)` 拆解：
  - `i / 3`：确定在第几行宫格（0/1/2）
  - `(i / 3) * 3`：行宫格的起始索引（0/3/6）
  - `j / 3`：确定在第几列宫格（0/1/2）
  - 两者相加得到宫格编号（0-8）

**终止/答案+边界**

+ 返回 false：发现任意一个数字在行、列或宫格中重复
+ 返回 true：遍历完所有格子，未发现冲突

**复杂度**

+ 时间复杂度：O(1)，实际遍历 9×9 = 81 个格子
+ 空间复杂度：O(1)，三个 9×9 的数组，共 243 个 boolean

**常见坑**

+ 宫格索引计算错误：`(i / 3) * 3 + (j / 3)` 而非 `i / 3 * 3 + j / 3`（注意运算优先级）
+ 字符转数字索引：需要减去 '1' 转换为 0-8，或使用 `d - '0' - 1`
+ 三个维度必须分别验证，不能只验证宫格就认为行列也满足




## 代码
### java
```plain
class Solution {
    public boolean isValidSudoku(char[][] board) {
        // 创建三个二维数组，分别记录行、列、宫格的数字出现情况
        // row[i][num]: 第i行是否已经出现过数字num+1
        // col[j][num]: 第j列是否已经出现过数字num+1
        // box[k][num]: 第k个宫格是否已经出现过数字num+1
        boolean[][] row = new boolean[9][9];
        boolean[][] col = new boolean[9][9];
        boolean[][] box = new boolean[9][9];

        // 遍历数独的每一个格子
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                // 跳过空格
                if (board[i][j] == '.') {
                    continue;
                }

                // 将字符 '1'-'9' 转换为索引 0-8
                int num = board[i][j] - '1';
                // 计算当前格子所属的宫格索引（0-8）
                int boxIndex = (i / 3) * 3 + (j / 3);

                // 检查该数字是否在当前行、列、宫格中已存在
                if (row[i][num] || col[j][num] || box[boxIndex][num]) {
                    return false;  // 存在冲突，数独无效
                }

                // 标记该数字已在当前行、列、宫格出现过
                row[i][num] = true;
                col[j][num] = true;
                box[boxIndex][num] = true;
            }
        }
        return true;  // 所有格子检查完毕，无冲突，数独有效
    }
}
```

### kotlin
```plain
class Solution {
    fun isValidSudoku(board: Array<CharArray>): Boolean {
        // 创建三个二维数组，分别记录行、列、宫格的数字出现情况
        val row = Array(9) { BooleanArray(9) }  // row[i][num]: 第i行是否已出现数字num+1
        val col = Array(9) { BooleanArray(9) }  // col[j][num]: 第j列是否已出现数字num+1
        val box = Array(9) { BooleanArray(9) }  // box[k][num]: 第k个宫格是否已出现数字num+1

        // 遍历数独的每一个格子
        for (i in 0..8) {
            for (j in 0..8) {
                // 跳过空格
                if (board[i][j] == '.') continue

                // 将字符 '1'-'9' 转换为索引 0-8
                val num = board[i][j] - '1'
                // 计算当前格子所属的宫格索引（0-8）
                val boxIndex = (i / 3) * 3 + (j / 3)

                // 检查该数字是否在当前行、列、宫格中已存在
                if (row[i][num] || col[j][num] || box[boxIndex][num]) {
                    return false  // 存在冲突，数独无效
                }

                // 标记该数字已在当前行、列、宫格出现过
                row[i][num] = true
                col[j][num] = true
                box[boxIndex][num] = true
            }
        }
        return true  // 所有格子检查完毕，无冲突，数独有效
    }
}
```

### 位运算优化版本（可选）
```plain
class Solution {
    public boolean isValidSudoku(char[][] board) {
        // 使用整数的9个二进制位来记录9个数字的出现情况
        // 例如：row[i] = 101010000 表示第i行已经出现了数字1,3,5
        int[] row = new int[9];   // row[i]: 第i行各数字的出现情况（用二进制位表示）
        int[] col = new int[9];   // col[j]: 第j列各数字的出现情况（用二进制位表示）
        int[] box = new int[9];   // box[k]: 第k个宫格各数字的出现情况（用二进制位表示）

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                // 跳过空格
                if (board[i][j] == '.') continue;

                // 计算掩码：数字'1'-'9'对应第0-8位
                // 例如数字'3' -> mask = 1 << 2 = 000000100（二进制）
                int mask = 1 << (board[i][j] - '1');
                // 计算当前格子所属的宫格索引（0-8）
                int boxIndex = (i / 3) * 3 + (j / 3);

                // 使用位运算检查数字是否已存在
                // 按位与：如果对应位为1，说明数字已存在
                if ((row[i] & mask) != 0 || (col[j] & mask) != 0 || (box[boxIndex] & mask) != 0) {
                    return false;  // 存在冲突，数独无效
                }

                // 使用位运算标记数字已出现
                // 按位或：将对应位置为1
                row[i] |= mask;       // 标记数字在第i行出现
                col[j] |= mask;       // 标记数字在第j列出现
                box[boxIndex] |= mask; // 标记数字在第boxIndex个宫格出现
            }
        }
        return true;  // 所有格子检查完毕，无冲突，数独有效
    }
}
```
