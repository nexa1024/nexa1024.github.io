---
title: DSA-Day05-128.最长连续序列
date: 2026-1-26 00:00:00
categories: 数据结构与算法
---

## 题目概述
**哈希表去重与序列起点判断**。本题是 LeetCode 中等题，核心考点是**使用 HashSet 在 O(n) 时间内找到最长连续序列**，巧妙之处在于只从序列起点开始统计。

## 为什么这道题重要
这是 **哈希表优化遍历** 的经典问题，掌握后可理解：
- 如何通过判断序列起点避免重复遍历
- 用空间换时间，将 O(n log n) 排序优化到 O(n)
- HashSet 在去重和快速查找中的应用

### 延伸应用
- 序列查找思想 → 延伸至：[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)（本题）
- 连续性判断 → 延伸至：[846. 一手顺子](https://leetcode.cn/problems/hand-of-straights/)、[1296. 划分数组为连续数字的集合](https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/)

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 排序 + 遍历 | O(n log n) | O(1) | 需要排序，破坏原数组顺序 |
| **HashSet 优化** | **O(n)** | **O(n)** | **最优解，从序列起点开始统计** |
| 并查集 | O(n α(n)) | O(n) | 适合动态添加元素的场景 |

**背诵重点**：HashSet 优化解法（O(n) 时间，序列起点判断）

⚠️ **注意**：本题要求 O(n) 时间复杂度，因此排序法不符合要求。关键优化点：**只从序列起点（num-1 不在集合中）开始统计长度**。

<!--more-->

## 题目
![](/images/algos/Day05-128.Longest_Consecutive_Sequence/01.png)

## 标签
数组、哈希表、并查集

## 背诵模型
**模型/状态**

+ 使用 **HashSet** 存储数组中的所有数字（自动去重）
+ 用变量 `longestStreak` 记录当前找到的最长连续序列长度

**不变量/约束**

+ HashSet 包含数组中所有不重复的数字
+ 只有当一个数字是**连续序列的起点**时（即 num - 1 不在集合中），才从它开始向后统计

**推进/转移**

+ 遍历 HashSet 中的每个数字 num：
  1. **判断是否为序列起点**：如果 num - 1 不在 HashSet 中，说明 num 是某个连续序列的起点
  2. **从起点向后统计**：初始化 currentNum = num，currentStreak = 1
  3. **循环查找下一个数**：当 currentNum + 1 在 HashSet 中时，currentNum++，currentStreak++
  4. **更新最大值**：统计结束后，用 currentStreak 更新 longestStreak

**关键优化点**

+ **避免重复统计**：对于序列 [1, 2, 3, 4]，只有 1 是起点（0 不在集合中），从 2、3、4 开始时会跳过
+ **时间复杂度分析**：虽然内层有 while 循环，但每个数字最多被访问两次（一次在外层 for，一次在内层 while），总时间复杂度仍为 O(n)

**终止/答案+边界**

+ 遍历完 HashSet 中所有数字后，返回 longestStreak
+ 边界情况：
  - 空数组：返回 0
  - 单元素数组：返回 1
  - 所有元素相同：返回 1（HashSet 去重后只有一个元素）

**复杂度**

+ 时间复杂度：O(n)，n 为数组长度。虽然内外层循环，但每个元素最多被访问 2 次
+ 空间复杂度：O(n)，HashSet 存储最多 n 个不重复元素

**常见坑**

+ **必须从序列起点统计**：如果不判断 num - 1 是否存在，会重复统计，导致时间复杂度退化为 O(n²)
+ **去重处理**：数组中可能有重复元素，需要用 HashSet 自动去重
+ **整数范围**：注意题目中 nums[i] 的范围是 -10⁹ 到 10⁹，可能会出现边界情况




## 代码
### java
```plain
class Solution {
    public int longestConsecutive(int[] nums) {
        // 创建 HashSet 存储所有数字（自动去重）
        Set<Integer> set = new HashSet<Integer>();
        for (int num : nums) {
            set.add(num);
        }

        int longestStreak = 0;  // 记录最长连续序列长度

        // 遍历 HashSet 中的每个数字
        for (int num : set) {
            // 关键优化：只有当 num 是序列起点时才开始统计
            // 即 num - 1 不在集合中，说明 num 是某个连续序列的起点
            if (!set.contains(num - 1)) {
                int currentNum = num;      // 当前数字
                int currentStreak = 1;     // 当前序列长度

                // 向后查找连续的数字
                while (set.contains(currentNum + 1)) {
                    currentNum++;
                    currentStreak++;
                }

                // 更新最长序列长度
                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }

        return longestStreak;
    }
}
```

### kotlin
```plain
class Solution {
    fun longestConsecutive(nums: IntArray): Int {
        // 创建 HashSet 存储所有数字（自动去重）
        val set = nums.toSet()

        var longestStreak = 0  // 记录最长连续序列长度

        // 遍历 HashSet 中的每个数字
        for (num in set) {
            // 关键优化：只有当 num 是序列起点时才开始统计
            // 即 num - 1 不在集合中，说明 num 是某个连续序列的起点
            if (!set.contains(num - 1)) {
                var currentNum = num      // 当前数字
                var currentStreak = 1     // 当前序列长度

                // 向后查找连续的数字
                while (set.contains(currentNum + 1)) {
                    currentNum++
                    currentStreak++
                }

                // 更新最长序列长度
                longestStreak = maxOf(longestStreak, currentStreak)
            }
        }

        return longestStreak
    }
}
```

### 复杂度分析图解
```
示例：nums = [100, 4, 200, 1, 3, 2]

HashSet = {100, 4, 200, 1, 3, 2}

遍历过程：
┌─────────┬──────────────┬────────────────────────┬────────┐
│   num   │ 是否为起点   │       统计过程          │  结果  │
├─────────┼──────────────┼────────────────────────┼────────┤
│   100   │ ✓ (99不存在) │ 100→101(不存在)         │ 长度1  │
│   4     │ ✗ (3存在)    │ 跳过（非起点）          │   -    │
│   200   │ ✓ (199不存在)│ 200→201(不存在)         │ 长度1  │
│   1     │ ✓ (0不存在)  │ 1→2→3→4→5(不存在)      │ 长度4  │
│   3     │ ✗ (2存在)    │ 跳过（非起点）          │   -    │
│   2     │ ✗ (1存在)    │ 跳过（非起点）          │   -    │
└─────────┴──────────────┴────────────────────────┴────────┘

最长序列：[1, 2, 3, 4]，长度 = 4

时间复杂度分析：
- 外层 for 循环：遍历 6 个元素（去重后）
- 内层 while 循环：100(0次) + 4(0次) + 200(0次) + 1(3次) + 3(0次) + 2(0次) = 3 次
- 总访问次数：6 + 3 = 9 次 = O(n) = O(6)

关键点：虽然嵌套循环，但每个元素最多被访问 2 次
  - 一次在外层 for 循环
  - 一次在内层 while 循环（仅当它是序列起点时）
```
