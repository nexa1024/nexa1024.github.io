---
title: DSA-Day02-1.两数之和
date: 2026-1-16 00:00:00
categories: 数据结构与算法
---

## 题目概述
**哈希表经典应用**。本题是 LeetCode 第一题，核心考点是**使用哈希表在一次遍历中找到目标和的两个元素**，是面试必考题。

## 为什么这道题重要
这是 **哈希表查找**的经典应用，是 LeetCode 最受欢迎的题目。本题有两种核心解法：

### 解法延伸路径
- **哈希解法（本题推荐）** → 延伸至：[454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)（分组哈希思想）
- **双指针解法** → 延伸至：[15. 三数之和](https://leetcode.cn/problems/3sum/)、[18. 四数之和](https://leetcode.cn/problems/4sum/)（排序+双指针思想）

⚠️ **注意**：三数之和和四数之和的最优解是**双指针法**，不是哈希法（哈希法在多元素求和时去重复杂且效率降低）

## 解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|-----------|-----------|---------|
| 暴力枚举 | O(n²) | O(1) | 性能差，不推荐 |
| **HashMap** | **O(n)** | **O(n)** | **本题最优解，无需排序** |
| 排序 + 双指针 | O(n log n) | O(1) | 需要返回元素值时适用，可延伸至三数/四数之和 |

**背诵重点**：HashMap 解法（O(n) 时间，边遍历边查找）

### 两种解法的选择
- **哈希解法**：题目要求返回下标，且数组无序 → **选择哈希**
- **双指针解法**：题目要求返回元素值，或可以排序 → **选择双指针**（可延伸至三数/四数之和）

<!--more-->

## 题目
![](/images/algos/Day02-1.Two_Sum/01.png)

## 标签
数组、哈希表

## 背诵模型
**模型/状态**

+ 我用一个**HashMap**记录数组nums的每一个元素,key是元素，value是下标

**不变量/约束**

+ 遍历nums到i的位置，HashMap的key包含[0, i-1]这个区间的元素

**推进/转移**

+ target-nums[i]在HashMap内无法找到对应的元素，nums[i]和i作为key和value放入HashMap

**终止/答案+边界**

+ 终止：
    - nums循环结束也没有在HashMap中找到对应元素
    - 找到对应元素

**复杂度**

+ 时间复杂度：O(n)，其中 n 为 nums 的长度。
+ 空间复杂度：O(n)，其中 n 为 nums 的长度。

**常见坑**
+ 无




## 代码
### java
```plain
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```

### kotlin
```plain
class Solution {
    fun twoSum(nums: IntArray, target: Int): IntArray {
        val map = hashMapOf<Int, Int>()
        nums.forEachIndexed { i, num ->
            val complement = target - num
            if (map.containsKey(complement)) {
                return intArrayOf(map.get(complement)!!, i)
            }
            map[num] = i
        }
        return intArrayOf()
    }
}
```

