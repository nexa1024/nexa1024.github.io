<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-Day02-RecycleView&amp;路由跳转</title>
    <url>/android/Day02-recycleview_router/</url>
    <content><![CDATA[<p>Day2 目标很明确：把“首页实验列表（RecyclerView）→ 点击进入实验页（Fragment）→ 返回回列表”这条最小导航链路跑通。你只需要做到“能跳转、能返回、Toolbar 返回箭头逻辑正确”，不需要做任何性能实验内容。</p>
<span id="more"></span>
<h1 id="按产出拆成-4-件事"><a href="#按产出拆成-4-件事" class="headerlink" title="按产出拆成 4 件事"></a>按产出拆成 4 件事</h1><h3 id="首页：RecyclerView-显示实验入口列表"><a href="#首页：RecyclerView-显示实验入口列表" class="headerlink" title="首页：RecyclerView 显示实验入口列表"></a>首页：RecyclerView 显示实验入口列表</h3><ul>
<li>做一个 LabItem 数据结构（id、标题、简介、tags 可先不做或先留空）</li>
<li>LabListFragment 展示一个 RecyclerView 列表（至少 6 项占位）：<ul>
<li>启动优化</li>
<li>卡顿&#x2F;Jank</li>
<li>泄漏</li>
<li>OOM</li>
<li>ANR</li>
<li>Crash</li>
</ul>
</li>
</ul>
<h3 id="路由：点击列表项能进入对应-LabFragment"><a href="#路由：点击列表项能进入对应-LabFragment" class="headerlink" title="路由：点击列表项能进入对应 LabFragment"></a>路由：点击列表项能进入对应 LabFragment</h3><ul>
<li>做一个 LabRegistry（注册表）：<ul>
<li>all() 返回上述 6 个 LabItem</li>
<li>createFragment(id) 返回对应的 Fragment（先是空页面&#x2F;占位页面也可以）</li>
</ul>
</li>
</ul>
<h3 id="Activity：负责切换-Fragment-back-stack"><a href="#Activity：负责切换-Fragment-back-stack" class="headerlink" title="Activity：负责切换 Fragment + back stack"></a>Activity：负责切换 Fragment + back stack</h3><ul>
<li>MainActivity.openLab(id)：<ul>
<li>replace(R.id.main_container, LabRegistry.createFragment(id))</li>
<li>addToBackStack(id)</li>
</ul>
</li>
</ul>
<h3 id="Toolbar：返回箭头显示-隐藏（Day2-的“完成标志”）"><a href="#Toolbar：返回箭头显示-隐藏（Day2-的“完成标志”）" class="headerlink" title="Toolbar：返回箭头显示&#x2F;隐藏（Day2 的“完成标志”）"></a>Toolbar：返回箭头显示&#x2F;隐藏（Day2 的“完成标志”）</h3><ul>
<li>在列表页：Toolbar 不显示返回箭头</li>
<li>进入实验页：Toolbar 显示返回箭头，点击能返回列表</li>
<li>实现方式：监听 supportFragmentManager.addOnBackStackChangedListener { … }，根据 backStack 是否为空来决定 supportActionBar?.setDisplayHomeAsUpEnabled(…)</li>
</ul>
<h1 id="RecyclerView-显示实验入口列表"><a href="#RecyclerView-显示实验入口列表" class="headerlink" title="RecyclerView 显示实验入口列表"></a>RecyclerView 显示实验入口列表</h1><h3 id="新建数据结构：LabItem"><a href="#新建数据结构：LabItem" class="headerlink" title="新建数据结构：LabItem"></a>新建数据结构：LabItem</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;nexa&#x2F;perfstabilitylab&#x2F;core&#x2F;LabItem.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.nexa.perfstabilitylab.core</span><br><span class="line"></span><br><span class="line">data class LabItem(</span><br><span class="line">    val id: String,</span><br><span class="line">    val title: String,</span><br><span class="line">    val desc: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="新建列表页布局：fragment-lab-list-xml"><a href="#新建列表页布局：fragment-lab-list-xml" class="headerlink" title="新建列表页布局：fragment_lab_list.xml"></a>新建列表页布局：fragment_lab_list.xml</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;res&#x2F;layout&#x2F;fragment_lab_list.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/rv_labs&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;16dp&quot;</span><br><span class="line">    android:clipToPadding=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure>


<h3 id="新建列表-item-布局：item-lab-xml"><a href="#新建列表-item-布局：item-lab-xml" class="headerlink" title="新建列表 item 布局：item_lab.xml"></a>新建列表 item 布局：item_lab.xml</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;res&#x2F;layout&#x2F;item_lab.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:paddingVertical=&quot;12dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_title&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;16sp&quot;</span><br><span class="line">        android:textStyle=&quot;bold&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_desc&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginTop=&quot;4dp&quot;</span><br><span class="line">        android:textSize=&quot;13sp&quot;</span><br><span class="line">        android:alpha=&quot;0.75&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>


<h3 id="新建-Adapter：LabListAdapter"><a href="#新建-Adapter：LabListAdapter" class="headerlink" title="新建 Adapter：LabListAdapter"></a>新建 Adapter：LabListAdapter</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;nexa&#x2F;perfstabilitylab&#x2F;ui&#x2F;home&#x2F;LabListAdapter.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.nexa.perfstabilitylab.ui.home</span><br><span class="line"></span><br><span class="line">import android.view.LayoutInflater</span><br><span class="line">import android.view.View</span><br><span class="line">import android.view.ViewGroup</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.recyclerview.widget.RecyclerView</span><br><span class="line">import com.nexa.perfstabilitylab.R</span><br><span class="line">import com.nexa.perfstabilitylab.core.LabItem</span><br><span class="line"></span><br><span class="line">class LabListAdapter(</span><br><span class="line">    private val items: List&lt;LabItem&gt;</span><br><span class="line">) : RecyclerView.Adapter&lt;LabListAdapter.VH&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    class VH(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">        val title: TextView = itemView.findViewById(R.id.tv_title)</span><br><span class="line">        val desc: TextView = itemView.findViewById(R.id.tv_desc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH &#123;</span><br><span class="line">        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_lab, parent, false)</span><br><span class="line">        return VH(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: VH, position: Int) &#123;</span><br><span class="line">        val item = items[position]</span><br><span class="line">        holder.title.text = item.title</span><br><span class="line">        holder.desc.text = item.desc</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount(): Int = items.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="新建-Fragment：LabListFragment"><a href="#新建-Fragment：LabListFragment" class="headerlink" title="新建 Fragment：LabListFragment"></a>新建 Fragment：LabListFragment</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;nexa&#x2F;perfstabilitylab&#x2F;ui&#x2F;home&#x2F;LabListFragment.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.nexa.perfstabilitylab.ui.home</span><br><span class="line"></span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.view.View</span><br><span class="line">import androidx.fragment.app.Fragment</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import androidx.recyclerview.widget.RecyclerView</span><br><span class="line">import com.nexa.perfstabilitylab.R</span><br><span class="line">import com.nexa.perfstabilitylab.core.LabItem</span><br><span class="line"></span><br><span class="line">class LabListFragment : Fragment(R.layout.fragment_lab_list) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;</span><br><span class="line">        val rv = view.findViewById&lt;RecyclerView&gt;(R.id.rv_labs)</span><br><span class="line">        rv.layoutManager = LinearLayoutManager(requireContext())</span><br><span class="line"></span><br><span class="line">        val items = listOf(</span><br><span class="line">            LabItem(&quot;startup&quot;, &quot;启动优化&quot;, &quot;冷/温/热启动、初始化治理、首帧直觉&quot;),</span><br><span class="line">            LabItem(&quot;jank&quot;, &quot;卡顿 / Jank&quot;, &quot;主线程阻塞、IO、锁等待、UI/GC&quot;),</span><br><span class="line">            LabItem(&quot;leak&quot;, &quot;内存泄漏&quot;, &quot;引用链、生命周期注销&quot;),</span><br><span class="line">            LabItem(&quot;oom&quot;, &quot;OOM&quot;, &quot;峰值、Bitmap、缓存上限、降级&quot;),</span><br><span class="line">            LabItem(&quot;anr&quot;, &quot;ANR&quot;, &quot;无响应、主线程卡死/等待&quot;),</span><br><span class="line">            LabItem(&quot;crash&quot;, &quot;Crash&quot;, &quot;栈+上下文、定位与闭环&quot;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        rv.adapter = LabListAdapter(items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MainActivity-启动时显示这个列表-Fragment"><a href="#MainActivity-启动时显示这个列表-Fragment" class="headerlink" title="MainActivity 启动时显示这个列表 Fragment"></a>MainActivity 启动时显示这个列表 Fragment</h3><p>在 MainActivity.onCreate() 里（setContentView 之后）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (savedInstanceState == null) &#123;</span><br><span class="line">    supportFragmentManager.beginTransaction()</span><br><span class="line">        .replace(R.id.main_container, LabListFragment())</span><br><span class="line">        .commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>———</p>
<h2 id="Step1-完成验收"><a href="#Step1-完成验收" class="headerlink" title="Step1 完成验收"></a>Step1 完成验收</h2><ul>
<li>App 启动后看到 6 条实验入口列表。<br><img src="/images/android/Day02-recyclerview_router/01.png"></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day02-1.两数之和</title>
    <url>/algos/Day02-1.Two_Sum/</url>
    <content><![CDATA[<p>1.两数之和背诵模板</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/algos/Day02-1.Two_Sum/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、哈希表</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个<strong>HashMap</strong>记录数组nums的每一个元素,key是元素，value是下标</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历nums到i的位置，HashMap的key包含[0, i-1]这个区间的元素</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>target-nums[i]在HashMap内无法找到对应的元素，nums[i]和i作为key和value放入HashMap</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li>nums循环结束也没有在HashMap中找到对应元素</li>
<li>找到对应元素</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 的长度。</li>
<li>空间复杂度：O(n)，其中 n 为 nums 的长度。</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>无</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            if (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun twoSum(nums: IntArray, target: Int): IntArray &#123;</span><br><span class="line">        val map = hashMapOf&lt;Int, Int&gt;()</span><br><span class="line">        nums.forEachIndexed &#123; i, num -&gt;</span><br><span class="line">            val complement = target - num</span><br><span class="line">            if (map.containsKey(complement)) &#123;</span><br><span class="line">                return intArrayOf(map.get(complement)!!, i)</span><br><span class="line">            &#125;</span><br><span class="line">            map[num] = i</span><br><span class="line">        &#125;</span><br><span class="line">        return intArrayOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day02-49.字母异位词分组</title>
    <url>/algos/Day02-49.Group_Anagrams/</url>
    <content><![CDATA[<ol start="49">
<li>字母异位词分组背诵模板</li>
</ol>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/algos/Day02-49.Group_Anagrams/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、哈希表、字符串、排序</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个<strong>HashMap</strong>记录strs中每个字符串排序后的结果作为key，数组作为value</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历strs到i的位置，HashMap的key包含[0, i-1]这个区间的排序好的元素，value则是存入数组</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>找到对应排序好的key，将当前元素push进数组</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li>终止：<ul>
<li>循环结束</li>
</ul>
</li>
<li>边界：<ul>
<li>单个元素</li>
<li>空数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li><p>时间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣&#x3D;26。需要遍历 n 个字符串，对于每个字符串，需要 O(k) 的时间计算每个字母出现的次数，O(∣Σ∣) 的时间生成哈希表的键，以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(n(k+∣Σ∣))。</p>
</li>
<li><p>空间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣&#x3D;26。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 O(∣Σ∣)，在渐进意义下小于 O(n(k+∣Σ∣))，可以忽略不计。</p>
</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>无</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun groupAnagrams(strs: Array&lt;String&gt;): List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        val map = hashMapOf&lt;String, MutableList&lt;String&gt;&gt;()</span><br><span class="line"></span><br><span class="line">        for (str:String in strs) &#123;</span><br><span class="line">            // strs每个字符串内容重新排序作为key</span><br><span class="line">            val key = str.toCharArray().sorted().joinToString(&quot;&quot;);</span><br><span class="line">            val values = map.getOrDefault(key, mutableListOf())</span><br><span class="line">            values.add(str)</span><br><span class="line">            map.put(key, values)</span><br><span class="line">        &#125;</span><br><span class="line">        return map.values.toList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day01-242.有效的字母异位词背诵模板</title>
    <url>/algos/Day01-242.Valid_Anagram/</url>
    <content><![CDATA[<ol start="242">
<li>有效的字母异位词背诵模板</li>
</ol>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/algos/Day01-242.Valid_Anagram/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>字符串、哈希、排序</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个<strong>HashMap</strong>记录<strong>s</strong>的所有字符出现的次数，key为字符，value为次数</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历 <strong>s <strong>到 <strong>i <strong>的位置，<strong>i-1</strong>的字符在</strong>HashMap</strong>都作为了</strong>key</strong>，并且所有<strong>value</strong>都是<strong>大于0</strong>。</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>循环<strong>t</strong>中的字符，找到<strong>HashMap</strong>中对应的<strong>key，<strong>如果找到则</strong>value–</strong></li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li><strong>t</strong>和<strong>s</strong>的长度不一致</li>
<li><strong>t</strong>的字符在<strong>HashMap</strong>的<strong>key</strong>中无法找到。</li>
<li><strong>t</strong>的字符在<strong>HashMap</strong>的<strong>value</strong>在**-1<strong>之前已经为</strong>0**</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 s 的长度。</li>
<li>空间复杂度：O(S)，其中 S 为字符集大小</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>无</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line"></span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (char c: s.toCharArray()) &#123;</span><br><span class="line">            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(char c: t.toCharArray()) &#123;</span><br><span class="line">            if (!frequencyMap.containsKey(c)) return false;</span><br><span class="line">            int count = frequencyMap.get(c);</span><br><span class="line">            if (count == 0) &#123; // 若t中字符出现次数超过s，返回false</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            frequencyMap.put(c, count - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun isAnagram(s: String, t: String): Boolean &#123;</span><br><span class="line">        if (s.length != t.length) return false</span><br><span class="line">        </span><br><span class="line">        val frequencyMap = mutableMapOf&lt;Char, Int&gt;()</span><br><span class="line">        for (c in s) &#123;</span><br><span class="line">            frequencyMap[c] = frequencyMap.getOrDefault(c, 0) + 1</span><br><span class="line">        &#125;</span><br><span class="line">        for (c in t) &#123;</span><br><span class="line">            if (!frequencyMap.containsKey(c)) return false</span><br><span class="line">            val count = frequencyMap[c]!!  // 安全获取（因已检查存在性）</span><br><span class="line">            if (count == 0) return false</span><br><span class="line">            frequencyMap[c] = count - 1</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day01-217.存在重复元素</title>
    <url>/algos/Day01-217.Contains_Duplicate/</url>
    <content><![CDATA[<p>217.存在重复元素背诵模板</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/algos/Day01-217.Contains_Duplicate/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、哈希、排序</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个哈希seen记录已经出现过的元素。</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历到第 i 个元素时，seen 包含了前 i-1 个元素出现过的所有值</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>arr[i]没有出现在seen中</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：当arr[i]出现在seen中。</li>
<li>边界：空数组</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>忘记将数组元素add入哈希</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Number&gt; seensSet = new HashSet&lt;Number&gt;();</span><br><span class="line">        for(int x: nums) &#123;</span><br><span class="line">            if(seensSet.contains(x)) return true;</span><br><span class="line">            seensSet.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun containsDuplicate(nums: IntArray): Boolean &#123;</span><br><span class="line">        val seensSet = HashSet&lt;Int&gt;(nums.size)</span><br><span class="line">        for(n: Int in nums) &#123;</span><br><span class="line">            if(seensSet.contains(n)) return true</span><br><span class="line">            seensSet.add(n)</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Android-Day01-搭建基础工程+ToolBar容器</title>
    <url>/android/Day01-skeleton_toolbar/</url>
    <content><![CDATA[<p>第一天搭建基础工程+toolbar</p>
<span id="more"></span>

<h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><ol>
<li>选择Empty Views Activity(<strong>重要，选择其他的可能会使用Jetpack Compose</strong>)</li>
<li>minSdk 33</li>
<li>targetSdk 36</li>
</ol>
<h1 id="镜像问题"><a href="#镜像问题" class="headerlink" title="镜像问题"></a>镜像问题</h1><h2 id="修改gradle到国内镜像"><a href="#修改gradle到国内镜像" class="headerlink" title="修改gradle到国内镜像"></a>修改gradle到国内镜像</h2><p>路径：项目根目录\gradle\wrapper\gradle-wrapper.properties</p>
<p>将原有的gradle.org修改为阿里云镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">distributionUrl=https://mirrors.aliyun.com/macports/distfiles/gradle/gradle-8.13-all.zip</span><br><span class="line">#distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-all.zip</span><br></pre></td></tr></table></figure>

<h2 id="修改插件和库依赖到国内镜像"><a href="#修改插件和库依赖到国内镜像" class="headerlink" title="修改插件和库依赖到国内镜像"></a>修改插件和库依赖到国内镜像</h2><p>插件为项目提供构建、测试、打包等能力，库提供可复用的代码&#x2F;资源</p>
<h3 id="AndroidStudio较新版本-例如-Arctic-Fox-2021-3-1-及之后"><a href="#AndroidStudio较新版本-例如-Arctic-Fox-2021-3-1-及之后" class="headerlink" title="AndroidStudio较新版本 (例如 Arctic Fox 2021.3.1 及之后)"></a>AndroidStudio较新版本 (例如 Arctic Fox 2021.3.1 及之后)</h3><ul>
<li>项目根目录存在settings.gradle,在文件当中会存在pluginManagement和 dependencyResolutionManagement代码块。</li>
</ul>
<h3 id="AndroidStudio旧版本-2021-3-1-之前"><a href="#AndroidStudio旧版本-2021-3-1-之前" class="headerlink" title="AndroidStudio旧版本 (2021.3.1 之前)"></a>AndroidStudio旧版本 (2021.3.1 之前)</h3><ul>
<li>项目根目录下的 <code>build.gradle</code>或 <code>build.gradle.kts</code></li>
<li>主要的仓库配置在根目录的 <code>build.gradle</code>文件的 <code>buildscript</code>和 <code>allprojects</code>部分。</li>
</ul>
<h3 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        // 插件新加3行</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;</span><br><span class="line">        google &#123;</span><br><span class="line">            content &#123;</span><br><span class="line">                includeGroupByRegex(&quot;com\\.android.*&quot;)</span><br><span class="line">                includeGroupByRegex(&quot;com\\.google.*&quot;)</span><br><span class="line">                includeGroupByRegex(&quot;androidx.*&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        // 库加2行</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rootProject.name = &quot;PerfStabilityLab&quot;</span><br><span class="line">include(&quot;:app&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="搭建项目骨架"><a href="#搭建项目骨架" class="headerlink" title="搭建项目骨架"></a>搭建项目骨架</h1><h2 id="避免系统自带标题栏和ToolBar冲突"><a href="#避免系统自带标题栏和ToolBar冲突" class="headerlink" title="避免系统自带标题栏和ToolBar冲突"></a>避免系统自带标题栏和ToolBar冲突</h2><p>使用NoActionBar，res&#x2F;values&#x2F;themes.xml（或 styles.xml，看你工程生成的名字）确认类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.PerfStabilityLab&quot; parent=&quot;Theme.Material3.DayNight.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;!-- 其他颜色配置随便 --&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p> 并检查 AndroidManifest.xml 里 Application 或 Activity 使用了这个主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:theme=&quot;@style/Theme.PerfStabilityLab&quot; ... /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="在activity-main-xml修改布局"><a href="#在activity-main-xml修改布局" class="headerlink" title="在activity_main.xml修改布局"></a>在activity_main.xml修改布局</h2><p>用LinearLayout比较直观，改成上下结构，放置一个MaterialToolbar和FragmentContainerView</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;LinearLayout</span><br><span class="line">      xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">      xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">      android:orientation=&quot;vertical&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;com.google.android.material.appbar.MaterialToolbar</span><br><span class="line">          android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">          android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          app:title=&quot;PerfStabilityLab&quot; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;androidx.fragment.app.FragmentContainerView</span><br><span class="line">          android:id=&quot;@+id/main_container&quot;</span><br><span class="line">          android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;0dp&quot;</span><br><span class="line">          android:layout_weight=&quot;1&quot; /&gt;</span><br><span class="line">  &lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/android/Day01-skeleton_toolbar/01.png"></p>
<h2 id="ToolBar设置为ActionBar，放占位Fragment"><a href="#ToolBar设置为ActionBar，放占位Fragment" class="headerlink" title="ToolBar设置为ActionBar，放占位Fragment"></a>ToolBar设置为ActionBar，放占位Fragment</h2><h3 id="新建Fragment，命名为PlaceholderFragment"><a href="#新建Fragment，命名为PlaceholderFragment" class="headerlink" title="新建Fragment，命名为PlaceholderFragment"></a>新建Fragment，命名为PlaceholderFragment</h3><p>放入一个占位的TextView即可，新建Fragment的时候会自动生成PlaceholderFragment.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># res/layout/fragment_placeholder.xml：</span><br><span class="line"></span><br><span class="line">&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:text=&quot;Placeholder&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="MainActivity修改"><a href="#MainActivity修改" class="headerlink" title="MainActivity修改"></a>MainActivity修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        enableEdgeToEdge()</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 设置ActionBar</span><br><span class="line">        val toolBar = findViewById&lt;MaterialToolbar&gt;(R.id.toolbar)</span><br><span class="line">        setSupportActionBar(toolBar)</span><br><span class="line"></span><br><span class="line">        // 把状态栏/刘海区域的高度加到 toolbar 的 top padding</span><br><span class="line">        val initialTopPadding = toolBar.paddingTop</span><br><span class="line">        ViewCompat.setOnApplyWindowInsetsListener(toolBar) &#123; v, insets -&gt;</span><br><span class="line">            val topInset = insets.getInsets(WindowInsetsCompat.Type.statusBars()).top</span><br><span class="line">            v.updatePadding(top = initialTopPadding + topInset)</span><br><span class="line">            insets</span><br><span class="line">        &#125;</span><br><span class="line">        ViewCompat.requestApplyInsets(toolBar)</span><br><span class="line"></span><br><span class="line">        // 先设置左上角返回按钮点击事件，day2再做显示隐藏逻辑</span><br><span class="line">        toolBar.setNavigationOnClickListener &#123;</span><br><span class="line">            onBackPressedDispatcher.onBackPressed()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (savedInstanceState == null) &#123;</span><br><span class="line">            supportFragmentManager.beginTransaction()</span><br><span class="line">                .replace(R.id.main_container, PlaceholderFragment())</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行测试，确认项目骨架最小集可用"><a href="#运行测试，确认项目骨架最小集可用" class="headerlink" title="运行测试，确认项目骨架最小集可用"></a>运行测试，确认项目骨架最小集可用</h1><!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/android/Day01-skeleton_toolbar/02.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android-Day00-16周内重新复现性能学习计划</title>
    <url>/android/Day00-before_study/</url>
    <content><![CDATA[<p>计划：16周内重新复现性能学习计划</p>
<span id="more"></span>

<h2 id="每日固定配方（90-分钟）"><a href="#每日固定配方（90-分钟）" class="headerlink" title="每日固定配方（90 分钟）"></a>每日固定配方（90 分钟）</h2><ul>
<li><strong>15m 算法</strong>：2 题（写边界 + 复杂度 + 使用模板）</li>
<li><strong>45m 阅读 + 笔记</strong>：5–10 条要点 + 1 张流程&#x2F;机制图</li>
<li><strong>25m Demo 验证</strong>：复现 → 定位 → 修复&#x2F;规避 → 再验证</li>
<li><strong>5m 输出卡片</strong>：1 张卡片（60 秒可复述）</li>
</ul>
<blockquote>
<p>第 7 天：自由（休息&#x2F;补漏&#x2F;纯复盘），不纳入日历强制安排。</p>
</blockquote>
<hr>
<h2 id="Week-1：基线与证据链"><a href="#Week-1：基线与证据链" class="headerlink" title="Week 1：基线与证据链"></a>Week 1：基线与证据链</h2><ul>
<li>D1 工程初始化</li>
<li>D2 实验列表&#x2F;路由骨架</li>
<li>D3 统一日志&#x2F;落盘记录</li>
<li>D4 Trace 打点封装 + 综合模板题</li>
<li>D5 Profiler 基础走查（CPU&#x2F;Memory）+ 错题复盘</li>
<li>D6 周复盘：证据链模板 1 页 + 补弱项</li>
</ul>
<h2 id="Week-2：Perfetto-System-Trace-入门"><a href="#Week-2：Perfetto-System-Trace-入门" class="headerlink" title="Week 2：Perfetto&#x2F;System Trace 入门"></a>Week 2：Perfetto&#x2F;System Trace 入门</h2><ul>
<li>D1 Perfetto 抓取&#x2F;界面熟悉</li>
<li>D2 Trace section 打点覆盖关键路径</li>
<li>D3 Demo：主线程阻塞 200ms（证据可见）+ 去重题</li>
<li>D4 掉帧直觉（主线程&#x2F;渲染线程）</li>
<li>D5 输出《Perfetto 最小读法清单》+ 错题复盘</li>
<li>D6 周复盘：把工具步骤固化成 checklist</li>
</ul>
<h2 id="Week-3：启动链路（冷-温-热、首帧）"><a href="#Week-3：启动链路（冷-温-热、首帧）" class="headerlink" title="Week 3：启动链路（冷&#x2F;温&#x2F;热、首帧）"></a>Week 3：启动链路（冷&#x2F;温&#x2F;热、首帧）</h2><ul>
<li>D1 启动链路概览笔记</li>
<li>D2 Demo：Application 慢初始化模拟</li>
<li>D3 Demo：延迟&#x2F;按需初始化对比 </li>
<li>D4 学 Provider&#x2F;Application 时机</li>
<li>D5 输出《启动优化要点》</li>
<li>D6 周复盘：启动证据链（现象→证据→修复→回归）</li>
</ul>
<h2 id="Week-4：初始化治理（依赖-线程安全）"><a href="#Week-4：初始化治理（依赖-线程安全）" class="headerlink" title="Week 4：初始化治理（依赖&#x2F;线程安全）"></a>Week 4：初始化治理（依赖&#x2F;线程安全）</h2><ul>
<li>D1 “越早初始化越好是错的”</li>
<li>D2 Demo：后台 init 竞态&#x2F;可见性风险 </li>
<li>D3 Demo：初始化调度（按需触发</li>
<li>D4 线程安全常见坑整理</li>
<li>D5 输出《初始化清单：必须&#x2F;可延迟&#x2F;按需》</li>
<li>D6 周复盘：固化 3 个启动相关可复现实验</li>
</ul>
<h2 id="Week-5：卡顿基础（分类：IO-锁-布局-GC）"><a href="#Week-5：卡顿基础（分类：IO-锁-布局-GC）" class="headerlink" title="Week 5：卡顿基础（分类：IO&#x2F;锁&#x2F;布局&#x2F;GC）"></a>Week 5：卡顿基础（分类：IO&#x2F;锁&#x2F;布局&#x2F;GC）</h2><ul>
<li>D1 卡顿分类笔记</li>
<li>D2 Demo：IO 卡顿复现与定位</li>
<li>D3 Demo：锁等待卡顿复现与定位</li>
<li>D4 “如何证明某段代码 &gt;16ms”</li>
<li>D5 输出《卡顿排查顺序清单》</li>
<li>D6 周复盘：卡顿证据链一份</li>
</ul>
<h2 id="Week-6：UI-性能（布局-过绘-列表）"><a href="#Week-6：UI-性能（布局-过绘-列表）" class="headerlink" title="Week 6：UI 性能（布局&#x2F;过绘&#x2F;列表）"></a>Week 6：UI 性能（布局&#x2F;过绘&#x2F;列表）</h2><ul>
<li>D1 布局性能要点</li>
<li>D2 Demo：深层级 XML vs 优化版</li>
<li>D3 Demo：RecyclerView 常见掉帧错误用法</li>
<li>D4 Layout Inspector&#x2F;渲染相关工具熟悉</li>
<li>D5 输出《UI 卡顿一页纸》+ 错题复盘</li>
<li>D6 周复盘：UI 证据链走查一遍</li>
</ul>
<h2 id="Week-7：内存与泄漏（LeakCanary-引用链）"><a href="#Week-7：内存与泄漏（LeakCanary-引用链）" class="headerlink" title="Week 7：内存与泄漏（LeakCanary&#x2F;引用链）"></a>Week 7：内存与泄漏（LeakCanary&#x2F;引用链）</h2><ul>
<li>D1 泄漏根因清单</li>
<li>D2 Demo：静态引用泄漏复现&#x2F;修复 </li>
<li>D3 Demo：监听&#x2F;回调未注销泄漏复现&#x2F;修复 </li>
<li>D4 引用链判读方法 + 数据流中位数（理解）</li>
<li>D5 输出《泄漏排查：谁持有谁》+ 错题复盘</li>
<li>D6 周复盘：沉淀 3 个泄漏模板</li>
</ul>
<h2 id="Week-8：OOM-专题（Bitmap-缓存-抖动）"><a href="#Week-8：OOM-专题（Bitmap-缓存-抖动）" class="headerlink" title="Week 8：OOM 专题（Bitmap&#x2F;缓存&#x2F;抖动）"></a>Week 8：OOM 专题（Bitmap&#x2F;缓存&#x2F;抖动）</h2><ul>
<li>D1 Bitmap&#x2F;采样&#x2F;缓存直觉</li>
<li>D2 Demo：大图&#x2F;大分配可控 OOM（谨慎）</li>
<li>D3 Demo：downsample&#x2F;上限策略对比</li>
<li>D4 内存抖动→GC→卡顿链路 </li>
<li>D5 输出《OOM 治理清单》</li>
<li>D6 周复盘：OOM 证据链一份</li>
</ul>
<h2 id="Week-9：ANR-专题（输入-广播-Service-锁）"><a href="#Week-9：ANR-专题（输入-广播-Service-锁）" class="headerlink" title="Week 9：ANR 专题（输入&#x2F;广播&#x2F;Service&#x2F;锁）"></a>Week 9：ANR 专题（输入&#x2F;广播&#x2F;Service&#x2F;锁）</h2><ul>
<li>D1 ANR 分类与超时机制</li>
<li>D2 Demo：接近 ANR 的主线程阻塞（先可控）</li>
<li>D3 Demo：锁等待型“卡死”定位 </li>
<li>D4 ANR 线程栈&#x2F;trace 的读法</li>
<li>D5 输出《ANR 排查顺序：先栈后锁再Binder》+ 错题复盘</li>
<li>D6 周复盘：ANR 证据链一份</li>
</ul>
<h2 id="Week-10：Crash-治理（日志-混淆-回滚思路）"><a href="#Week-10：Crash-治理（日志-混淆-回滚思路）" class="headerlink" title="Week 10：Crash 治理（日志&#x2F;混淆&#x2F;回滚思路）"></a>Week 10：Crash 治理（日志&#x2F;混淆&#x2F;回滚思路）</h2><ul>
<li>D1 Crash 定位流程笔记</li>
<li>D2 Demo：常见 crash 复现（NPE&#x2F;越界&#x2F;状态）</li>
<li>D3 Demo：崩溃前上下文记录（线程&#x2F;页面&#x2F;操作）</li>
<li>D4 混淆与 mapping 的意义</li>
<li>D5 输出《Crash 闭环清单》+ 错题复盘</li>
<li>D6 周复盘：Crash 证据链一份</li>
</ul>
<h2 id="Week-11：协程稳定性（取消-异常-结构化并发）"><a href="#Week-11：协程稳定性（取消-异常-结构化并发）" class="headerlink" title="Week 11：协程稳定性（取消&#x2F;异常&#x2F;结构化并发）"></a>Week 11：协程稳定性（取消&#x2F;异常&#x2F;结构化并发）</h2><ul>
<li>D1 结构化并发与取消传播 </li>
<li>D2 Demo：取消不生效&#x2F;Job 泄漏复现修复</li>
<li>D3 Demo：异常传播导致全局失败复现修复 </li>
<li>D4 Flow 冷&#x2F;热与生命周期取消直觉</li>
<li>D5 输出《协程排错清单》+ 错题复盘</li>
<li>D6 周复盘：协程事故复盘模板</li>
</ul>
<h2 id="Week-12：网络与弱网稳定性（超时-重试-幂等-降级）"><a href="#Week-12：网络与弱网稳定性（超时-重试-幂等-降级）" class="headerlink" title="Week 12：网络与弱网稳定性（超时&#x2F;重试&#x2F;幂等&#x2F;降级）"></a>Week 12：网络与弱网稳定性（超时&#x2F;重试&#x2F;幂等&#x2F;降级）</h2><ul>
<li>D1 超时&#x2F;重试&#x2F;幂等关系笔记 </li>
<li>D2 Demo：可配置超时&#x2F;重试请求模拟器 </li>
<li>D3 Demo：失败降级&#x2F;缓存兜底策略 </li>
<li>D4 缓存直觉与弱网策略 </li>
<li>D5 输出《弱网治理清单》</li>
<li>D6 周复盘：网络稳定性证据链</li>
</ul>
<h2 id="Week-13：沉淀《性能稳定性手册》"><a href="#Week-13：沉淀《性能稳定性手册》" class="headerlink" title="Week 13：沉淀《性能稳定性手册》"></a>Week 13：沉淀《性能稳定性手册》</h2><ul>
<li>D1 整理启动章节 </li>
<li>D2 整理卡顿章节</li>
<li>D3 整理泄漏&#x2F;OOM章节</li>
<li>D4 整理 ANR&#x2F;Crash&#x2F;网络章节 </li>
<li>D5 压缩成 2 页“排查路径图”</li>
<li>D6 周复盘：Demo 实验目录化&#x2F;可复用化</li>
</ul>
<h2 id="Week-14：深挖掉帧定位（渲染-帧调度直觉）"><a href="#Week-14：深挖掉帧定位（渲染-帧调度直觉）" class="headerlink" title="Week 14：深挖掉帧定位（渲染&#x2F;帧调度直觉）"></a>Week 14：深挖掉帧定位（渲染&#x2F;帧调度直觉）</h2><ul>
<li>D1 渲染&#x2F;帧调度概览 </li>
<li>D2 Demo：统计帧耗时分布（简单版）</li>
<li>D3 Demo：频繁 requestLayout&#x2F;invalidate 抖动复现 </li>
<li>D4 常见掉帧模式总结</li>
<li>D5 输出《掉帧定位证据链》</li>
<li>D6 周复盘：掉帧完整走查</li>
</ul>
<h2 id="Week-15：深挖-GC-分配与卡顿关联-补短板"><a href="#Week-15：深挖-GC-分配与卡顿关联-补短板" class="headerlink" title="Week 15：深挖 GC&#x2F;分配与卡顿关联 + 补短板"></a>Week 15：深挖 GC&#x2F;分配与卡顿关联 + 补短板</h2><ul>
<li>D1 GC 暂停直觉（不背收集器名）+ 补短板题</li>
<li>D2 Demo：频繁分配→GC→卡顿复现观察 + 补短板题</li>
<li>D3 Demo：减少分配&#x2F;复用对比验证 + 补短板题</li>
<li>D4 内存优化工程手段总结 + 补短板题</li>
<li>D5 输出《GC 卡顿：证明与缓解》+ 补短板题</li>
<li>D6 周复盘：GC 证据链一份</li>
</ul>
<h2 id="Week-16：综合闭环周（每类再跑一遍）-回顾"><a href="#Week-16：综合闭环周（每类再跑一遍）-回顾" class="headerlink" title="Week 16：综合闭环周（每类再跑一遍）+ 回顾"></a>Week 16：综合闭环周（每类再跑一遍）+ 回顾</h2><ul>
<li>D1 启动闭环 + 回顾题</li>
<li>D2 卡顿闭环 + 回顾题</li>
<li>D3 泄漏&#x2F;OOM 闭环 + 回顾题</li>
<li>D4 ANR 闭环 + 回顾题</li>
<li>D5 Crash&#x2F;网络闭环 + 回顾题</li>
<li>D6 总复盘：手册+Demo 资产清单与后续维护计划</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>DAS-DAY00-数据结构与算法必看</title>
    <url>/algos/Day00-before-studying/</url>
    <content><![CDATA[<p>更多的是对于已经对数据结构与算法有一定了解的人，可以复习，我不知道对于新手是否有帮助。</p>
<span id="more"></span>

<h2 id="针对的人群"><a href="#针对的人群" class="headerlink" title="针对的人群"></a>针对的人群</h2><p>更多的是对于已经对数据结构与算法有一定了解的人，可以复习，我不知道对于新手是否有帮助。</p>
<h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><h3 id="模型（Model-State）"><a href="#模型（Model-State）" class="headerlink" title="模型（Model &#x2F; State）"></a>模型（Model &#x2F; State）</h3><p><strong>一句话：模型&#x3D;你维护的“状态容器”是什么。</strong></p>
<p>“模型”就是你把题目抽象成的状态表示和数据结构：你打算用什么来描述当前进度&#x2F;信息。</p>
<p>例如：</p>
<ul>
<li><p>双指针题：模型 &#x3D; l&#x2F;r 指针位置（以及它们代表的区间含义）</p>
</li>
<li><p>滑动窗口：模型 &#x3D; [l,r] 窗口 + 计数表&#x2F;和等统计量</p>
</li>
<li><p>哈希判重：模型 &#x3D; seen 集合（已出现的元素集合）</p>
</li>
<li><p>BFS：模型 &#x3D; 队列中的节点 + visited&#x2F;dist</p>
</li>
<li><p>DP：模型 &#x3D; dp[i] 的定义（dp 数组含义）</p>
<hr>
</li>
</ul>
<h3 id="不变量（Invariant）"><a href="#不变量（Invariant）" class="headerlink" title="不变量（Invariant）"></a>不变量（Invariant）</h3><p>  “不变量”是指在算法执行过程中，始终保持为真的条件&#x2F;性质。它是正确性的支点。<strong>一句话：不变量&#x3D;你每一步都不破坏的“保证正确的规则”。</strong></p>
<p>  以哈希判重为例：</p>
<ul>
<li>不变量：遍历到第 i 个元素时，seen 包含了前 i-1 个元素出现过的所有值。</li>
<li>因为这个不变量成立，所以当你看到新元素 x 时：<ul>
<li>x in seen ⇒ 前面已经出现过 ⇒ 至少两次 ⇒ 可以返回 true</li>
</ul>
</li>
</ul>
<h3 id="推进（Progress-Transition）"><a href="#推进（Progress-Transition）" class="headerlink" title="推进（Progress &#x2F; Transition）"></a>推进（Progress &#x2F; Transition）</h3><p> <strong>一句话：推进&#x3D;每一步怎么更新状态，怎么缩小问题规模。</strong></p>
<p>每次循环&#x2F;递归&#x2F;迭代时，你如何：</p>
<pre><code>- 更新状态（模型）
- 让算法向结束更近（避免死循环）
- 同时保持不变量成立
</code></pre>
<p> 哈希判重的推进：</p>
<pre><code>- 读取 x
- 如果已存在：返回 true
- 否则加入 seen（更新状态）并继续遍历
</code></pre>
<p> 双指针的推进：</p>
<ul>
<li>比较后移动 l 或 r（指针前进&#x2F;收缩区间）</li>
</ul>
<h3 id="终止（Termination）"><a href="#终止（Termination）" class="headerlink" title="终止（Termination）"></a>终止（Termination）</h3><p> <strong>一句话：终止&#x3D;什么时候结束、结束时答案是什么。</strong></p>
<p>  “终止”描述两个问题：</p>
<ol>
<li>算法在什么条件下停（停止条件）</li>
<li>停的时候答案怎么取（返回什么）</li>
</ol>
<p>  哈希判重的终止：</p>
<ul>
<li><p>提前终止：发现重复立刻返回 true</p>
</li>
<li><p>正常终止：遍历完仍无重复返回 false</p>
<p>BFS 的终止：</p>
</li>
<li><p>找到目标返回最短距离</p>
</li>
<li><p>队列空说明不可达</p>
<p>把它们连起来就是你背诵时的逻辑链：<br><strong>模型（我维护什么）→ 不变量（我凭什么正确）→ 推进（我每步怎么做）→ 终止（何时停&#x2F;返回啥）</strong></p>
</li>
</ul>
<h2 id="必看路径"><a href="#必看路径" class="headerlink" title="必看路径"></a>必看路径</h2><p>参考url：<a href="https://neetcode.io/roadmap">https://neetcode.io/roadmap</a> 150题路径</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>基于Find Cpu HotSpots分析调用栈</title>
    <url>/android/basic_trace/</url>
    <content><![CDATA[<p>通过Find Cpu HotSpots分析调用栈，在对项目代码不熟悉的情况下，能帮助我们尽快定位对应的入口与触发的函数。</p>
<span id="more"></span>

<h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><h2 id="真机调试和远程屏幕准备"><a href="#真机调试和远程屏幕准备" class="headerlink" title="真机调试和远程屏幕准备"></a>真机调试和远程屏幕准备</h2><p>真机打开开发者选项和调试模式，参考这个url或自行搜索即可<a href="https://developer.android.google.cn/studio/debug/dev-options?hl=zh-cn">https://developer.android.google.cn/studio/debug/dev-options?hl=zh-cn</a></p>
<p>在github下载QtScrcpy,<a href="https://github.com/barry-ran/QtScrcpy/releases">https://github.com/barry-ran/QtScrcpy/releases</a></p>
<p>当<strong>真机打开了usb调试之后</strong>，打开QtScrcpy软件，能看到我们的真机，双击打开就可以显示屏幕，我们在电脑上远程操作真机屏幕，不用运行虚拟机，节省一些资源。</p>
<p><img src="/images/android/basic_trace/sc1.png"></p>
<p><img src="/images/android/basic_trace/sc2.png"></p>
<h2 id="官方项目准备"><a href="#官方项目准备" class="headerlink" title="官方项目准备"></a>官方项目准备</h2><p>这里以官方的示例项目的jetnews作为我们的演示项目<a href="https://github.com/android/compose-samples">https://github.com/android/compose-samples</a></p>
<h3 id="gradle镜像配置"><a href="#gradle镜像配置" class="headerlink" title="gradle镜像配置"></a>gradle镜像配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// jetnews/gradle/wrapper/gradle-wrapper.properties</span><br><span class="line">// 修改为aliyun镜像，并且gradle-8.13-bin.zip可以修改为gradle-8.13-all.zip</span><br><span class="line">distributionUrl=https\://mirrors.aliyun.com/macports/distfiles/gradle/gradle-8.13-all.zip</span><br></pre></td></tr></table></figure>

<h3 id="插件镜像"><a href="#插件镜像" class="headerlink" title="插件镜像"></a>插件镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// jetnews/setting.gradle.kts</span><br><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url=uri (&quot;https://www.jitpack.io&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/releases&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/google&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/central&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/public&quot;)&#125;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        snapshotVersion?.let &#123;</span><br><span class="line">            println(&quot;https://androidx.dev/snapshots/builds/$it/artifacts/repository/&quot;)</span><br><span class="line">            maven &#123; url = uri(&quot;https://androidx.dev/snapshots/builds/$it/artifacts/repository/&quot;) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://www.jitpack.io&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/releases&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/google&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/central&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/public&quot;)&#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装app到真机"><a href="#安装app到真机" class="headerlink" title="安装app到真机"></a>安装app到真机</h3><p><img src="/images/android/basic_trace/sc3.png"></p>
<h1 id="录制trace文件"><a href="#录制trace文件" class="headerlink" title="录制trace文件"></a>录制trace文件</h1><p>先打开profile，不然看不到录制入口<br><img src="/images/android/basic_trace/sc4.png"></p>
<p>选择进程，Find Cpu Spots, 开始录制<br><img src="/images/android/basic_trace/sc5.png"></p>
<p>开始录制后根据要求操作屏幕，可以是点击跳转，滑动等，操作完屏幕点击停止录制，会生成trace文件，我们可以导出trace文件</p>
<p><img src="/images/android/basic_trace/sc6.png"></p>
<h1 id="分析trace文件"><a href="#分析trace文件" class="headerlink" title="分析trace文件"></a>分析trace文件</h1><p>打开这个url <a href="https://profiler.firefox.com/%EF%BC%8C%E5%B0%86trace%E6%96%87%E4%BB%B6%E6%8B%96%E5%85%A5%E7%BD%91%E9%A1%B5">https://profiler.firefox.com/，将trace文件拖入网页</a></p>
<p>因为app运行在主线程，点击main和栈图，筛选输入click，查看绿色部分，可以发现点击的时候，触发了一堆包下的方法，那么知道了这些包名和方法，就可以通过全局搜索查到对应的入口了</p>
<p><img src="/images/android/basic_trace/sc7.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>I&#39;m back</title>
    <url>/something/imback/</url>
    <content><![CDATA[<p>在今天开始，网站重新部署了，一切正在往好的方向发展，26年加油~~~~~</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
</search>
