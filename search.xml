<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DSA-Day03-238.除自身以外数组的乘积</title>
    <url>/algos/Day03-238.Product_Except_Self/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><strong>前缀积与后缀积的经典应用</strong>。本题是 LeetCode 中等难度题，核心考点是<strong>在不使用除法的情况下，计算除自身以外的数组乘积</strong>，要求 O(n) 时间复杂度和 O(1) 额外空间（输出数组除外）。</p>
<h2 id="为什么这道题重要"><a href="#为什么这道题重要" class="headerlink" title="为什么这道题重要"></a>为什么这道题重要</h2><p>这是 <strong>前缀和&#x2F;前缀积思想</strong>的典范，掌握后可解决：</p>
<ul>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a>（本题）</li>
<li><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li>
</ul>
<p>关键在于<strong>将问题分解为前缀积和后缀积两部分</strong>，避免了除法的使用（除法会遇到 0 的特殊情况）。</p>
<h2 id="解法对比"><a href="#解法对比" class="headerlink" title="解法对比"></a>解法对比</h2><table>
<thead>
<tr>
<th>解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>暴力枚举</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>对每个位置计算其他元素乘积，性能差</td>
</tr>
<tr>
<td>左右乘积列表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>用两个数组分别存储前缀和后缀积</td>
</tr>
<tr>
<td><strong>输出数组复用（最优）</strong></td>
<td><strong>O(n)</strong></td>
<td><strong>O(1)</strong></td>
<td><strong>用输出数组存前缀，变量存后缀</strong></td>
</tr>
</tbody></table>
<p><strong>背诵重点</strong>：输出数组复用解法（满足 O(1) 额外空间）</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/algos/Day03-238.Product_Except_Self/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、前缀和</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用<strong>answer 数组</strong>先存储每个位置<strong>左侧所有元素的乘积</strong>（前缀积），再用一个<strong>变量 R</strong> 记录<strong>右侧所有元素的乘积</strong>（后缀积）</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>第一次遍历（左到右）：<ul>
<li>answer[i] 存储的是 nums[0] × nums[1] × … × nums[i-1]</li>
<li>answer[0] &#x3D; 1（左边没有元素）</li>
</ul>
</li>
<li>第二次遍历（右到左）：<ul>
<li>R 记录当前位置右侧所有元素的乘积</li>
<li>answer[i] &#x3D; answer[i] × R（左侧乘积 × 右侧乘积）</li>
<li>R &#x3D; R × nums[i]（更新后缀积）</li>
</ul>
</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>第一次遍历（计算前缀积）：<ul>
<li>answer[i] &#x3D; answer[i-1] × nums[i-1]</li>
</ul>
</li>
<li>第二次遍历（计算后缀积并更新答案）：<ul>
<li>R 初始化为 1</li>
<li>answer[i] &#x3D; answer[i] × R</li>
<li>R &#x3D; R × nums[i]</li>
</ul>
</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li>两次遍历完成</li>
</ul>
</li>
<li>边界：<ul>
<li>首元素：前缀积为 1，只有后缀积</li>
<li>末元素：后缀积为 1，只有前缀积</li>
<li>数组长度为 2：每个位置的乘积就是对方元素</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 是数组长度。需要遍历数组两次，第一次计算前缀积，第二次计算后缀积并更新答案，因此总时间复杂度是 O(n)。</p>
</li>
<li><p>空间复杂度：O(1)，除了输出数组外，只使用了常数个额外变量（R）。题目说明输出数组不算额外空间。</p>
</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>不能使用除法！遇到 0 会导致除零错误或逻辑错误</li>
<li>第一次遍历时 answer[0] &#x3D; 1（左边没有元素）</li>
<li>第二次遍历从右向左，R 初始化为 1（右边没有元素）</li>
<li>注意更新 R 的顺序：先使用 R 更新 answer[i]，再更新 R &#x3D; R × nums[i]</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="kotlin-输出数组复用解法（O-n-时间，O-1-空间）"><a href="#kotlin-输出数组复用解法（O-n-时间，O-1-空间）" class="headerlink" title="kotlin - 输出数组复用解法（O(n) 时间，O(1) 空间）"></a>kotlin - 输出数组复用解法（O(n) 时间，O(1) 空间）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun productExceptSelf(nums: IntArray): IntArray &#123;</span><br><span class="line">        val n = nums.size</span><br><span class="line">        val answer = IntArray(n)</span><br><span class="line"></span><br><span class="line">        // 1. 计算前缀积（左侧所有元素的乘积）</span><br><span class="line">        answer[0] = 1</span><br><span class="line">        for (i in 1 until n) &#123;</span><br><span class="line">            answer[i] = answer[i - 1] * nums[i - 1]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 计算后缀积（右侧所有元素的乘积）并更新答案</span><br><span class="line">        var R = 1</span><br><span class="line">        for (i in n - 1 downTo 0) &#123;</span><br><span class="line">            answer[i] = answer[i] * R</span><br><span class="line">            R *= nums[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-输出数组复用解法（O-n-时间，O-1-空间）"><a href="#java-输出数组复用解法（O-n-时间，O-1-空间）" class="headerlink" title="java - 输出数组复用解法（O(n) 时间，O(1) 空间）"></a>java - 输出数组复用解法（O(n) 时间，O(1) 空间）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] answer = new int[n];</span><br><span class="line"></span><br><span class="line">        // 1. 计算前缀积（左侧所有元素的乘积）</span><br><span class="line">        answer[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            answer[i] = answer[i - 1] * nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 计算后缀积（右侧所有元素的乘积）并更新答案</span><br><span class="line">        int R = 1;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day03-347.前K个高频元素</title>
    <url>/algos/Day03-Top-K-Frequent/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><strong>Top K 问题的经典应用</strong>。本题是 LeetCode 中等难度题，核心考点是<strong>在 O(n) 时间复杂度内找出前 k 个高频元素</strong>，是 Google、Meta 等大厂面试高频题。</p>
<h2 id="为什么这道题重要"><a href="#为什么这道题重要" class="headerlink" title="为什么这道题重要"></a>为什么这道题重要</h2><p>这是 <strong>Top K 问题</strong>的典范，掌握后可举一反三解决：</p>
<ul>
<li><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 第 K 个最大元素</a></li>
<li><a href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前 K 个高频单词</a></li>
<li><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前K个高频元素</a>（本题）</li>
</ul>
<p>关键不在统计频率（HashMap 基础操作），而在如何<strong>高效地选出 Top K</strong>。进阶要求时间复杂度必须优于 O(n log n)，这迫使你必须使用<strong>桶排序</strong>。</p>
<h2 id="解法对比"><a href="#解法对比" class="headerlink" title="解法对比"></a>解法对比</h2><table>
<thead>
<tr>
<th>解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>哈希表 + 排序</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>基础解法</td>
</tr>
<tr>
<td>哈希表 + 小顶堆</td>
<td>O(n log k)</td>
<td>O(n)</td>
<td>k &lt;&lt; n 时较优</td>
</tr>
<tr>
<td><strong>哈希表 + 桶排序</strong></td>
<td><strong>O(n)</strong></td>
<td>O(n)</td>
<td><strong>最优解，推荐背诵</strong></td>
</tr>
</tbody></table>
<p><strong>背诵重点</strong>：桶排序解法（满足进阶要求 O(n)）</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/algos/Day03-Top-K-Frequent/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、哈希表、分治、桶排序、计数、快速选择、排序、堆（优先队列）</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个<strong>HashMap</strong>统计每个元素的出现频率，再用一个<strong>桶数组</strong>（索引为频率，值为元素列表）存储</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历HashMap到当前元素，桶数组中满足：<ul>
<li>索引 i 的桶中存储所有出现频率为 i 的元素</li>
<li>频率范围是 [1, n]，因此创建 n+1 个桶</li>
<li>桶是按频率天然有序的（索引越大，频率越高）</li>
</ul>
</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>对于每个(元素, 频率)对：<ul>
<li>直接放入对应频率索引的桶中：buckets[freq].add(num)</li>
</ul>
</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li>从高频率桶（索引 n）向低频率桶（索引 1）遍历</li>
<li>收集元素直到凑够 k 个</li>
</ul>
</li>
<li>边界：<ul>
<li>k&#x3D;1：只返回频率最高的1个元素</li>
<li>所有元素频率都不同：题目保证答案唯一</li>
<li>k等于元素种类数：返回所有元素</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 是数组长度。统计频率需要 O(n)，创建桶并填充需要 O(n)，从高到低遍历桶最坏需要 O(n)，因此总时间复杂度是 O(n)。满足进阶要求（优于 O(n log n)）。</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是数组长度。哈希表最坏需要存储 O(n) 个键值对，桶数组需要 O(n) 空间。</p>
</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>桶的大小必须是 n+1（频率范围是 1 到 n）</li>
<li>从高频率向低频率遍历，不要反了</li>
</ul>
<ul>
<li>使用 <code>downTo</code> 而不是 <code>until</code> 进行倒序遍历</li>
<li>收集结果时注意判断 <code>result.size &gt;= k</code>，避免数组越界</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="kotlin-桶排序解法（O-n-最优解）"><a href="#kotlin-桶排序解法（O-n-最优解）" class="headerlink" title="kotlin - 桶排序解法（O(n) 最优解）"></a>kotlin - 桶排序解法（O(n) 最优解）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun topKFrequent(nums: IntArray, k: Int): IntArray &#123;</span><br><span class="line">        // 1. 统计频率</span><br><span class="line">        val freqMap = HashMap&lt;Int, Int&gt;()</span><br><span class="line">        for (num in nums) &#123;</span><br><span class="line">            freqMap[num] = freqMap.getOrDefault(num, 0) + 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 创建桶（索引为频率，值为元素列表）</span><br><span class="line">        val n = nums.size</span><br><span class="line">        val buckets = Array&lt;MutableList&lt;Int&gt;&gt;(n + 1) &#123; mutableListOf() &#125;</span><br><span class="line"></span><br><span class="line">        for ((num, freq) in freqMap) &#123;</span><br><span class="line">            buckets[freq].add(num)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 从高频率向低频率遍历</span><br><span class="line">        val result = mutableListOf&lt;Int&gt;()</span><br><span class="line">        for (i in n downTo 1) &#123;</span><br><span class="line">            result.addAll(buckets[i])</span><br><span class="line">            if (result.size &gt;= k) &#123;</span><br><span class="line">                return result.take(k).toIntArray()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result.toIntArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-桶排序解法（O-n-最优解）"><a href="#java-桶排序解法（O-n-最优解）" class="headerlink" title="java - 桶排序解法（O(n) 最优解）"></a>java - 桶排序解法（O(n) 最优解）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        // 1. 统计频率</span><br><span class="line">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 创建桶（索引为频率，值为元素列表）</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        List&lt;Integer&gt;[] buckets = new List[n + 1];</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            buckets[i] = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : freqMap.entrySet()) &#123;</span><br><span class="line">            int num = entry.getKey();</span><br><span class="line">            int freq = entry.getValue();</span><br><span class="line">            buckets[freq].add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 从高频率向低频率遍历</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = n; i &gt;= 1; i--) &#123;</span><br><span class="line">            result.addAll(buckets[i]);</span><br><span class="line">            if (result.size() &gt;= k) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 转换为数组</span><br><span class="line">        int[] ans = new int[k];</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = result.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Android-Day-01-02 实现总结</title>
    <url>/android/Day01-02-summary/</url>
    <content><![CDATA[<h2 id="PerfStabilityLab：性能与稳定性演示项目"><a href="#PerfStabilityLab：性能与稳定性演示项目" class="headerlink" title="PerfStabilityLab：性能与稳定性演示项目"></a>PerfStabilityLab：性能与稳定性演示项目</h2><p><strong>PerfStabilityLab</strong> 是一个专注于 Android 性能与稳定性优化的演示项目，通过动手实验的方式复现启动优化、卡顿、内存泄漏、OOM、ANR、Crash 等典型问题。</p>
<p><strong>技术栈</strong>：Kotlin + View&#x2F;XML + 单Activity + Fragment架构 (SDK 33-36)</p>
<p><strong>Day01-02</strong>：搭建项目骨架（Toolbar+Fragment容器）+ RecyclerView导航链路</p>
<span id="more"></span>

<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p><strong>PerfStabilityLab</strong> 是一个专注于性能与稳定性的 Android 演示项目，通过动手实验的方式复现应用优化。</p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul>
<li><strong>语言</strong>: Kotlin</li>
<li><strong>最低 SDK</strong>: 33 (Android 13)</li>
<li><strong>目标 SDK</strong>: 36</li>
<li><strong>UI</strong>: View&#x2F;XML 布局（非 Jetpack Compose）</li>
<li><strong>架构</strong>: 单 Activity + Fragment 导航</li>
</ul>
<hr>
<h2 id="Day-1：项目骨架-导航容器"><a href="#Day-1：项目骨架-导航容器" class="headerlink" title="Day 1：项目骨架 + 导航容器"></a>Day 1：项目骨架 + 导航容器</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>搭建项目基础，配置 Toolbar 和 Fragment 容器，为后续实验做准备。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1. 项目初始化"></a>1. 项目初始化</h4><p>创建新的 Android 项目，配置：</p>
<ul>
<li>Kotlin 作为主要语言</li>
<li>基于 View&#x2F;XML 的 UI</li>
<li>Material Design 组件</li>
</ul>
<h4 id="2-MainActivity-结构"><a href="#2-MainActivity-结构" class="headerlink" title="2. MainActivity 结构"></a>2. MainActivity 结构</h4><p><strong>文件</strong>: <code>app/src/main/java/com/nexa/perfstabilitylab/MainActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.activity.enableEdgeToEdge</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.ViewCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.WindowInsetsCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.updatePadding</span><br><span class="line"><span class="keyword">import</span> com.google.android.material.appbar.MaterialToolbar</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.core.LabId</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.ui.home.LabListFragment</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.ui.lab.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 Toolbar 引用，用于后续控制导航图标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> toolbar: MaterialToolbar</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 启用边到边显示，实现现代 Android 全屏效果</span></span><br><span class="line">        enableEdgeToEdge()</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 MaterialToolbar 作为 ActionBar</span></span><br><span class="line">        toolbar = findViewById(R.id.toolbar)</span><br><span class="line">        setSupportActionBar(toolbar)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理状态栏 insets - 将状态栏高度添加到 Toolbar 的 top padding</span></span><br><span class="line">        <span class="comment">// 这样确保内容不会被状态栏遮挡</span></span><br><span class="line">        <span class="keyword">val</span> initialTopPadding = toolbar.paddingTop</span><br><span class="line">        ViewCompat.setOnApplyWindowInsetsListener(toolbar) &#123; v, insets -&gt;</span><br><span class="line">            <span class="comment">// 获取状态栏 insets（刘海/摄像头区域）</span></span><br><span class="line">            <span class="keyword">val</span> topInset = insets.getInsets(WindowInsetsCompat.Type.statusBars()).top</span><br><span class="line">            <span class="comment">// 更新 Toolbar padding 以适应状态栏</span></span><br><span class="line">            v.updatePadding(top = initialTopPadding + topInset)</span><br><span class="line">            insets</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求初始 insets 应用</span></span><br><span class="line">        ViewCompat.requestApplyInsets(toolbar)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置导航按钮点击监听（返回按钮）</span></span><br><span class="line">        toolbar.setNavigationOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 使用现代的 onBackPressedDispatcher 而非已弃用的 onBackPressed()</span></span><br><span class="line">            onBackPressedDispatcher.onBackPressed()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听返回栈变化，控制导航图标显示/隐藏</span></span><br><span class="line">        <span class="comment">// Day 2 要求：根据当前页面显示/隐藏返回箭头</span></span><br><span class="line">        supportFragmentManager.addOnBackStackChangedListener &#123;</span><br><span class="line">            updateNavigationIcon()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始设置：加载实验列表 Fragment</span></span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            supportFragmentManager.beginTransaction()</span><br><span class="line">                .replace(R.id.main_container, LabListFragment())</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化导航图标状态（列表页应隐藏返回箭头）</span></span><br><span class="line">        updateNavigationIcon()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导航到指定的实验页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> labId 要打开的实验 ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">openLab</span><span class="params">(labId: <span class="type">LabId</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 根据 Lab ID 创建对应的 Fragment</span></span><br><span class="line">        <span class="keyword">val</span> fragment = <span class="keyword">when</span> (labId) &#123;</span><br><span class="line">            LabId.STARTUP -&gt; StartupLabFragment()</span><br><span class="line">            LabId.JANK -&gt; JankLabFragment()</span><br><span class="line">            LabId.LEAK -&gt; LeakLabFragment()</span><br><span class="line">            LabId.OOM -&gt; OomLabFragment()</span><br><span class="line">            LabId.ANR -&gt; AnrLabFragment()</span><br><span class="line">            LabId.CRASH -&gt; CrashLabFragment()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从注册表获取实验信息并更新 Toolbar 标题</span></span><br><span class="line">        <span class="keyword">val</span> labItem = com.nexa.perfstabilitylab.core.LabRegistry.getLabById(labId)</span><br><span class="line">        supportActionBar?.title = labItem?.title ?: <span class="string">&quot;实验&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换 Fragment 并添加到返回栈</span></span><br><span class="line">        <span class="comment">// 这样用户可以返回到列表</span></span><br><span class="line">        supportFragmentManager.beginTransaction()</span><br><span class="line">            .replace(R.id.main_container, fragment)</span><br><span class="line">            .addToBackStack(labId.id)  <span class="comment">// 使用实验 ID 作为返回栈名称</span></span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据当前返回栈状态更新导航图标</span></span><br><span class="line"><span class="comment">     * - 列表页（无返回栈）：隐藏返回箭头，显示应用名称</span></span><br><span class="line"><span class="comment">     * - 实验页（有返回栈）：显示返回箭头，显示实验标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateNavigationIcon</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> hasBackStack = supportFragmentManager.backStackEntryCount &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (hasBackStack) &#123;</span><br><span class="line">            <span class="comment">// 在实验 Fragment 时显示返回箭头</span></span><br><span class="line">            toolbar.setNavigationIcon(com.google.android.material.R.drawable.abc_ic_ab_back_material)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在列表屏幕时隐藏返回箭头</span></span><br><span class="line">            toolbar.navigationIcon = <span class="literal">null</span></span><br><span class="line">            supportActionBar?.title = <span class="string">&quot;PerfStabilityLab&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>:</p>
<ul>
<li>使用 <code>enableEdgeToEdge()</code> 实现现代边到边显示</li>
<li>通过 <code>WindowInsetsCompat</code> 正确处理状态栏 insets</li>
<li>实现 <code>addOnBackStackChangedListener</code> 动态控制导航图标</li>
<li>使用现代的 <code>onBackPressedDispatcher</code> 替代已弃用的 <code>onBackPressed()</code></li>
</ul>
<h4 id="3-布局结构"><a href="#3-布局结构" class="headerlink" title="3. 布局结构"></a>3. 布局结构</h4><p><strong>文件</strong>: <code>app/src/main/res/layout/activity_main.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根布局使用 LinearLayout 实现垂直排列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Material Toolbar 作为 ActionBar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.appbar.MaterialToolbar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;?attr/colorPrimary&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Fragment 导航容器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所有 Fragment 将在此处显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_container&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Day-2：实验列表-导航系统"><a href="#Day-2：实验列表-导航系统" class="headerlink" title="Day 2：实验列表 + 导航系统"></a>Day 2：实验列表 + 导航系统</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>创建基于 RecyclerView 的实验列表，实现导航到各个实验 Fragment，并正确管理返回栈。</p>
<h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="1-LabId-枚举-类型安全的实验标识符"><a href="#1-LabId-枚举-类型安全的实验标识符" class="headerlink" title="1. LabId 枚举 - 类型安全的实验标识符"></a>1. LabId 枚举 - 类型安全的实验标识符</h4><p><strong>文件</strong>: <code>app/src/main/java/com/nexa/perfstabilitylab/core/LabId.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab.core</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实验ID枚举，提供类型安全的实验标识</span></span><br><span class="line"><span class="comment"> * 每个枚举值代表一个性能/稳定性主题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LabId</span>(<span class="keyword">val</span> id: String) &#123;</span><br><span class="line">    STARTUP(<span class="string">&quot;startup&quot;</span>),    <span class="comment">// 启动优化</span></span><br><span class="line">    JANK(<span class="string">&quot;jank&quot;</span>),          <span class="comment">// 掉帧/卡顿</span></span><br><span class="line">    LEAK(<span class="string">&quot;leak&quot;</span>),          <span class="comment">// 内存泄漏</span></span><br><span class="line">    OOM(<span class="string">&quot;oom&quot;</span>),            <span class="comment">// 内存溢出</span></span><br><span class="line">    ANR(<span class="string">&quot;anr&quot;</span>),            <span class="comment">// 应用无响应</span></span><br><span class="line">    CRASH(<span class="string">&quot;crash&quot;</span>);        <span class="comment">// 崩溃与稳定性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据字符串 ID 查找 LabId</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 匹配的 LabId，未找到返回 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromId</span><span class="params">(id: <span class="type">String</span>)</span></span>: LabId? &#123;</span><br><span class="line">            <span class="keyword">return</span> values().find &#123; it.id == id &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么使用枚举？</strong></p>
<ul>
<li><strong>类型安全</strong>: 编译器在编译时检查有效性</li>
<li><strong>避免魔法字符串</strong>: 集中管理 ID</li>
<li><strong>易于扩展</strong>: 添加新实验只需添加枚举值</li>
</ul>
<h4 id="2-LabItem-数据模型"><a href="#2-LabItem-数据模型" class="headerlink" title="2. LabItem 数据模型"></a>2. LabItem 数据模型</h4><p><strong>文件</strong>: <code>app/src/main/java/com/nexa/perfstabilitylab/core/LabItem.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab.core</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实验项数据模型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> labId 实验的枚举 ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> title 列表中显示的标题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desc 实验涵盖内容的简要描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tags 分类标签列表（可选，默认为空）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">LabItem</span>(</span><br><span class="line">    <span class="keyword">val</span> labId: LabId,</span><br><span class="line">    <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">val</span> desc: String,</span><br><span class="line">    <span class="keyword">val</span> tags: List&lt;String&gt; = emptyList()</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 暴露字符串 ID 以保持向后兼容</span></span><br><span class="line">    <span class="keyword">val</span> id: String <span class="keyword">get</span>() = labId.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计决策</strong>:</p>
<ul>
<li>使用 <code>LabId</code> 枚举而非原始字符串以提供类型安全</li>
<li><code>tags</code> 是可选参数，默认为空列表</li>
<li>暴露 <code>id</code> 属性以兼容基于字符串的 API</li>
</ul>
<h4 id="3-LabRegistry-集中式实验管理"><a href="#3-LabRegistry-集中式实验管理" class="headerlink" title="3. LabRegistry - 集中式实验管理"></a>3. LabRegistry - 集中式实验管理</h4><p><strong>文件</strong>: <code>app/src/main/java/com/nexa/perfstabilitylab/core/LabRegistry.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab.core</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有实验的中央注册表</span></span><br><span class="line"><span class="comment"> * 使用 object 声明（单例模式）实现全局访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> LabRegistry &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有可用实验的完整列表</span></span><br><span class="line">    <span class="keyword">val</span> allLabs: List&lt;LabItem&gt; = listOf(</span><br><span class="line">        LabItem(</span><br><span class="line">            labId = LabId.STARTUP,</span><br><span class="line">            title = <span class="string">&quot;启动优化&quot;</span>,</span><br><span class="line">            desc = <span class="string">&quot;冷/温/热启动、初始化治理、首帧直觉&quot;</span>,</span><br><span class="line">            tags = listOf(<span class="string">&quot;冷启动&quot;</span>, <span class="string">&quot;温启动&quot;</span>, <span class="string">&quot;热启动&quot;</span>, <span class="string">&quot;首帧&quot;</span>, <span class="string">&quot;初始化&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        LabItem(</span><br><span class="line">            labId = LabId.JANK,</span><br><span class="line">            title = <span class="string">&quot;卡顿 / Jank&quot;</span>,</span><br><span class="line">            desc = <span class="string">&quot;主线程阻塞、IO、锁等待、UI/GC&quot;</span>,</span><br><span class="line">            tags = listOf(<span class="string">&quot;主线程&quot;</span>, <span class="string">&quot;IO&quot;</span>, <span class="string">&quot;锁&quot;</span>, <span class="string">&quot;布局&quot;</span>, <span class="string">&quot;GC&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        LabItem(</span><br><span class="line">            labId = LabId.LEAK,</span><br><span class="line">            title = <span class="string">&quot;内存泄漏&quot;</span>,</span><br><span class="line">            desc = <span class="string">&quot;引用链、生命周期注销&quot;</span>,</span><br><span class="line">            tags = listOf(<span class="string">&quot;引用链&quot;</span>, <span class="string">&quot;生命周期&quot;</span>, <span class="string">&quot;LeakCanary&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        LabItem(</span><br><span class="line">            labId = LabId.OOM,</span><br><span class="line">            title = <span class="string">&quot;OOM&quot;</span>,</span><br><span class="line">            desc = <span class="string">&quot;峰值、Bitmap、缓存上限、降级&quot;</span>,</span><br><span class="line">            tags = listOf(<span class="string">&quot;Bitmap&quot;</span>, <span class="string">&quot;缓存&quot;</span>, <span class="string">&quot;内存抖动&quot;</span>, <span class="string">&quot;降级&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        LabItem(</span><br><span class="line">            labId = LabId.ANR,</span><br><span class="line">            title = <span class="string">&quot;ANR&quot;</span>,</span><br><span class="line">            desc = <span class="string">&quot;无响应、主线程卡死/等待&quot;</span>,</span><br><span class="line">            tags = listOf(<span class="string">&quot;主线程&quot;</span>, <span class="string">&quot;锁&quot;</span>, <span class="string">&quot;Binder&quot;</span>, <span class="string">&quot;Trace&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        LabItem(</span><br><span class="line">            labId = LabId.CRASH,</span><br><span class="line">            title = <span class="string">&quot;Crash&quot;</span>,</span><br><span class="line">            desc = <span class="string">&quot;栈+上下文、定位与闭环&quot;</span>,</span><br><span class="line">            tags = listOf(<span class="string">&quot;异常&quot;</span>, <span class="string">&quot;日志&quot;</span>, <span class="string">&quot;混淆&quot;</span>, <span class="string">&quot;监控&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 LabId 枚举获取实验信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到的 LabItem，未找到返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLabById</span><span class="params">(id: <span class="type">LabId</span>)</span></span>: LabItem? &#123;</span><br><span class="line">        <span class="keyword">return</span> allLabs.find &#123; it.labId == id &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据字符串 ID 获取实验信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到的 LabItem，未找到返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLabById</span><span class="params">(id: <span class="type">String</span>)</span></span>: LabItem? &#123;</span><br><span class="line">        <span class="keyword">return</span> LabId.fromId(id)?.let &#123; getLabById(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>:</p>
<ul>
<li>实验数据的唯一真实来源</li>
<li>易于添加新实验或修改现有实验</li>
<li>Object 声明确保只有一个实例存在</li>
<li>同时提供基于枚举和基于字符串的查找方法</li>
</ul>
<h4 id="4-实验列表-Fragment"><a href="#4-实验列表-Fragment" class="headerlink" title="4. 实验列表 Fragment"></a>4. 实验列表 Fragment</h4><p><strong>文件</strong>: <code>app/src/main/java/com/nexa/perfstabilitylab/ui/home/LabListFragment.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab.ui.home</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.MainActivity</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.R</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.core.LabRegistry</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主列表屏幕，显示所有可用实验</span></span><br><span class="line"><span class="comment"> * 用户点击项目导航到对应的实验 Fragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LabListFragment</span> : <span class="type">Fragment</span>(R.layout.fragment_lab_list) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从布局获取 RecyclerView</span></span><br><span class="line">        <span class="keyword">val</span> rv = view.findViewById&lt;RecyclerView&gt;(R.id.rv_labs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 LinearLayoutManager 实现垂直列表</span></span><br><span class="line">        rv.layoutManager = LinearLayoutManager(requireContext())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从注册表获取实验数据</span></span><br><span class="line">        <span class="keyword">val</span> items = LabRegistry.allLabs</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用数据创建适配器</span></span><br><span class="line">        <span class="keyword">val</span> adapter = LabListAdapter(items)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置点击监听器处理项目交互</span></span><br><span class="line">        adapter.onItemClickListener = &#123; item -&gt;</span><br><span class="line">            <span class="comment">// 通过 MainActivity 的路由方法导航到选定的实验</span></span><br><span class="line">            (requireActivity() <span class="keyword">as</span> MainActivity).openLab(item.labId)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将适配器附加到 RecyclerView</span></span><br><span class="line">        rv.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键概念</strong>:</p>
<ul>
<li>使用构造函数语法 <code>Fragment(R.layout.fragment_lab_list)</code> 进行布局填充</li>
<li><code>requireActivity()</code> 安全获取 Activity（如果为 null 则抛出异常）</li>
<li><code>requireContext()</code> 安全获取 Context（如果为 null 则抛出异常）</li>
<li>将导航逻辑委托给 MainActivity</li>
</ul>
<h4 id="5-实验列表适配器"><a href="#5-实验列表适配器" class="headerlink" title="5. 实验列表适配器"></a>5. 实验列表适配器</h4><p><strong>文件</strong>: <code>app/src/main/java/com/nexa/perfstabilitylab/ui/home/LabListAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab.ui.home</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.R</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.core.LabItem</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RecyclerView 适配器，用于显示实验列表</span></span><br><span class="line"><span class="comment"> * 使用 ViewHolder 模式实现高效滚动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LabListAdapter</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> items: List&lt;LabItem&gt;</span><br><span class="line">) : RecyclerView.Adapter&lt;LabListAdapter.VH&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击监听器属性（可空，由 Fragment 设置）</span></span><br><span class="line">    <span class="keyword">var</span> onItemClickListener: ((LabItem) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ViewHolder 保存项目视图的引用</span></span><br><span class="line"><span class="comment">     * 避免滚动时重复调用 findViewById</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">VH</span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">        <span class="keyword">val</span> title: TextView = itemView.findViewById(R.id.tv_title)</span><br><span class="line">        <span class="keyword">val</span> desc: TextView = itemView.findViewById(R.id.tv_desc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: VH &#123;</span><br><span class="line">        <span class="comment">// 填充项目布局（attachToRoot = false）</span></span><br><span class="line">        <span class="keyword">val</span> v = LayoutInflater.from(parent.context)</span><br><span class="line">            .inflate(R.layout.item_lab, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> VH(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">VH</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前位置的数据</span></span><br><span class="line">        <span class="keyword">val</span> item = items[position]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据绑定到视图</span></span><br><span class="line">        holder.title.text = item.title</span><br><span class="line">        holder.desc.text = item.desc</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在整个项目视图上设置点击监听器</span></span><br><span class="line">        holder.itemView.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 如果设置了回调则调用</span></span><br><span class="line">            onItemClickListener?.invoke(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = items.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RecyclerView 最佳实践</strong>:</p>
<ul>
<li>ViewHolder 模式缓存视图引用</li>
<li>LayoutInflater 中的 <code>attachToRoot = false</code>（RecyclerView 处理附加）</li>
<li>在 <code>onBindViewHolder</code> 中设置点击监听器以感知位置</li>
<li>Lambda 回调实现简洁的事件处理</li>
</ul>
<h4 id="6-实验-Fragment-基类"><a href="#6-实验-Fragment-基类" class="headerlink" title="6. 实验 Fragment 基类"></a>6. 实验 Fragment 基类</h4><p><strong>文件</strong>: <code>app/src/main/java/com/nexa/perfstabilitylab/ui/lab/BaseLabFragment.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab.ui.lab</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> com.google.android.material.chip.Chip</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.R</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.core.LabItem</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有实验 Fragment 的基类</span></span><br><span class="line"><span class="comment"> * 提供通用 UI 结构和数据绑定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子类只需提供 labItem 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseLabFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类必须重写此属性以提供其实验数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">val</span> labItem: LabItem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有实验 Fragment 使用通用布局</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_lab, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示实验标题和描述</span></span><br><span class="line">        view.findViewById&lt;android.widget.TextView&gt;(R.id.tv_lab_title).text = labItem.title</span><br><span class="line">        view.findViewById&lt;android.widget.TextView&gt;(R.id.tv_lab_desc).text = labItem.desc</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每个标签创建 Chip</span></span><br><span class="line">        <span class="keyword">val</span> chipGroup = view.findViewById&lt;com.google.android.material.chip.ChipGroup&gt;(R.id.cg_tags)</span><br><span class="line">        labItem.tags.forEach &#123; tag -&gt;</span><br><span class="line">            <span class="keyword">val</span> chip = Chip(requireContext()).apply &#123;</span><br><span class="line">                text = tag</span><br><span class="line">                isClickable = <span class="literal">false</span>      <span class="comment">// 标签仅用于显示，不可交互</span></span><br><span class="line">                chipBackgroundColor = <span class="literal">null</span>  <span class="comment">// 使用默认样式</span></span><br><span class="line">            &#125;</span><br><span class="line">            chipGroup.addView(chip)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模板方法模式</strong>:</p>
<ul>
<li>基类提供通用结构</li>
<li>子类只需重写 <code>labItem</code> 属性</li>
<li>减少了 6 个实验 Fragment 之间的代码重复</li>
</ul>
<h4 id="7-具体实验-Fragment"><a href="#7-具体实验-Fragment" class="headerlink" title="7. 具体实验 Fragment"></a>7. 具体实验 Fragment</h4><p>所有 6 个实验 Fragment 遵循相同的模式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StartupLabFragment.kt</span></span><br><span class="line"><span class="keyword">package</span> com.nexa.perfstabilitylab.ui.lab</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.core.LabId</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.core.LabItem</span><br><span class="line"><span class="keyword">import</span> com.nexa.perfstabilitylab.core.LabRegistry</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动优化实验页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StartupLabFragment</span> : <span class="type">BaseLabFragment</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过 ID 从注册表获取实验数据</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> labItem: LabItem <span class="keyword">get</span>() = LabRegistry.getLabById(LabId.STARTUP)!!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JankLabFragment.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JankLabFragment</span> : <span class="type">BaseLabFragment</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> labItem: LabItem <span class="keyword">get</span>() = LabRegistry.getLabById(LabId.JANK)!!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeakLabFragment.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeakLabFragment</span> : <span class="type">BaseLabFragment</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> labItem: LabItem <span class="keyword">get</span>() = LabRegistry.getLabById(LabId.LEAK)!!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OomLabFragment.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OomLabFragment</span> : <span class="type">BaseLabFragment</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> labItem: LabItem <span class="keyword">get</span>() = LabRegistry.getLabById(LabId.OOM)!!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnrLabFragment.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnrLabFragment</span> : <span class="type">BaseLabFragment</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> labItem: LabItem <span class="keyword">get</span>() = LabRegistry.getLabById(LabId.ANR)!!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CrashLabFragment.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CrashLabFragment</span> : <span class="type">BaseLabFragment</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> labItem: LabItem <span class="keyword">get</span>() = LabRegistry.getLabById(LabId.CRASH)!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DRY 原则</strong>:</p>
<ul>
<li>不要重复自己 - 基类处理所有通用逻辑</li>
<li>子类仅需约 10 行代码（导入和属性重写）</li>
<li>添加新实验非常简单：创建新 Fragment + 添加枚举值</li>
</ul>
<h4 id="8-实验-Fragment-布局"><a href="#8-实验-Fragment-布局" class="headerlink" title="8. 实验 Fragment 布局"></a>8. 实验 Fragment 布局</h4><p><strong>文件</strong>: <code>app/src/main/res/layout/fragment_lab.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 实验信息的卡片容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardElevation</span>=<span class="string">&quot;4dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardUseCompatPadding</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 实验标题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_lab_title&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">&quot;实验标题&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 实验描述 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_lab_desc&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">&quot;实验描述&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">&quot;14sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 标签容器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.google.android.material.chip.ChipGroup</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/cg_tags&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;8dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 实验内容的占位符 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 未来几天将被实际的实验 UI 替换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;实验内容待实现...&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">&quot;italic&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@android:color/darker_gray&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h2><h3 id="完整的用户旅程"><a href="#完整的用户旅程" class="headerlink" title="完整的用户旅程"></a>完整的用户旅程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 应用启动</span><br><span class="line">   └─&gt; MainActivity 创建 LabListFragment</span><br><span class="line">   └─&gt; Toolbar 显示 &quot;PerfStabilityLab&quot;（无返回箭头）</span><br><span class="line"></span><br><span class="line">2. 用户点击 &quot;卡顿 / Jank&quot;</span><br><span class="line">   └─&gt; LabListFragment 调用 MainActivity.openLab(LabId.JANK)</span><br><span class="line">   └─&gt; MainActivity 创建 JankLabFragment</span><br><span class="line">   └─&gt; Fragment 添加到返回栈，名称为 &quot;jank&quot;</span><br><span class="line">   └─&gt; Toolbar 显示 &quot;卡顿 / Jank&quot;（返回箭头可见）</span><br><span class="line"></span><br><span class="line">3. 用户点击返回箭头</span><br><span class="line">   └─&gt; 触发 onBackPressedDispatcher.onBackPressed()</span><br><span class="line">   └─&gt; JankLabFragment 从返回栈弹出</span><br><span class="line">   └─&gt; 返回到 LabListFragment</span><br><span class="line">   └─&gt; 触发 onBackStackChangedListener</span><br><span class="line">   └─&gt; updateNavigationIcon() 隐藏返回箭头</span><br><span class="line">   └─&gt; Toolbar 显示 &quot;PerfStabilityLab&quot;</span><br></pre></td></tr></table></figure>

<h3 id="返回栈管理"><a href="#返回栈管理" class="headerlink" title="返回栈管理"></a>返回栈管理</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加到返回栈</span></span><br><span class="line">supportFragmentManager.beginTransaction()</span><br><span class="line">    .replace(R.id.main_container, fragment)</span><br><span class="line">    .addToBackStack(labId.id)  <span class="comment">// &quot;jank&quot;, &quot;startup&quot; 等</span></span><br><span class="line">    .commit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查返回栈状态</span></span><br><span class="line"><span class="keyword">val</span> hasBackStack = supportFragmentManager.backStackEntryCount &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app/src/main/java/com/nexa/perfstabilitylab/</span><br><span class="line">├── MainActivity.kt                          # 单 Activity 与导航</span><br><span class="line">├── core/</span><br><span class="line">│   ├── LabId.kt                            # 实验 ID 枚举</span><br><span class="line">│   ├── LabItem.kt                          # 实验数据模型</span><br><span class="line">│   └── LabRegistry.kt                      # 中央实验注册表</span><br><span class="line">├── ui/</span><br><span class="line">│   ├── home/</span><br><span class="line">│   │   ├── LabListFragment.kt             # 主列表屏幕</span><br><span class="line">│   │   └── LabListAdapter.kt              # RecyclerView 适配器</span><br><span class="line">│   └── lab/</span><br><span class="line">│       ├── BaseLabFragment.kt             # 实验基类</span><br><span class="line">│       ├── StartupLabFragment.kt          # 启动实验</span><br><span class="line">│       ├── JankLabFragment.kt             # 卡顿实验</span><br><span class="line">│       ├── LeakLabFragment.kt             # 内存泄漏实验</span><br><span class="line">│       ├── OomLabFragment.kt              # OOM 实验</span><br><span class="line">│       ├── AnrLabFragment.kt              # ANR 实验</span><br><span class="line">│       └── CrashLabFragment.kt            # 崩溃实验</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关键学习点"><a href="#关键学习点" class="headerlink" title="关键学习点"></a>关键学习点</h2><h3 id="Android-基础"><a href="#Android-基础" class="headerlink" title="Android 基础"></a>Android 基础</h3><ol>
<li><strong>Fragment 导航</strong>: 使用 <code>addToBackStack()</code> 实现正确的返回导航</li>
<li><strong>边到边显示</strong>: 使用 <code>WindowInsetsCompat</code> 处理窗口 insets</li>
<li><strong>RecyclerView</strong>: 始终使用 ViewHolder 模式以提高性能</li>
<li><strong>单例模式</strong>: 使用 <code>object</code> 声明实现单例（如注册表）</li>
</ol>
<h3 id="Kotlin-最佳实践"><a href="#Kotlin-最佳实践" class="headerlink" title="Kotlin 最佳实践"></a>Kotlin 最佳实践</h3><ol>
<li><strong>数据类</strong>: 用于模型，自动生成 <code>equals()</code>、<code>hashCode()</code>、<code>copy()</code></li>
<li><strong>枚举类</strong>: 提供比原始字符串更好的类型安全</li>
<li><strong>空安全</strong>: 使用可空类型（<code>?</code>）和安全调用（<code>?.</code>）</li>
<li><strong>属性委托</strong>: 通过自定义 getter 暴露计算属性</li>
</ol>
<h3 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h3><ol>
<li><strong>单 Activity</strong>: 一个 Activity 托管多个 Fragment</li>
<li><strong>仓储模式</strong>: 中央注册表管理数据访问</li>
<li><strong>模板方法</strong>: 基类定义结构，子类自定义</li>
<li><strong>观察者模式</strong>: 监听器回调处理用户交互</li>
</ol>
<hr>
<h2 id="验收清单"><a href="#验收清单" class="headerlink" title="验收清单"></a>验收清单</h2><h3 id="Day-1-交付物-✅"><a href="#Day-1-交付物-✅" class="headerlink" title="Day 1 交付物 ✅"></a>Day 1 交付物 ✅</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 使用正确配置创建项目（minSdk 33）</li>
<li><input checked="" disabled="" type="checkbox"> 带有 MaterialToolbar 的 MainActivity</li>
<li><input checked="" disabled="" type="checkbox"> 用于托管 Fragment 的 FragmentContainerView</li>
<li><input checked="" disabled="" type="checkbox"> 正确处理 inset 的边到边显示</li>
<li><input checked="" disabled="" type="checkbox"> 导航按钮点击处理程序</li>
</ul>
<h3 id="Day-2-交付物-✅"><a href="#Day-2-交付物-✅" class="headerlink" title="Day 2 交付物 ✅"></a>Day 2 交付物 ✅</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 在 LabRegistry 中定义 6 个实验项</li>
<li><input checked="" disabled="" type="checkbox"> 带有 RecyclerView 的 LabListFragment</li>
<li><input checked="" disabled="" type="checkbox"> 带点击处理的 LabListAdapter</li>
<li><input checked="" disabled="" type="checkbox"> MainActivity.openLab() 路由方法</li>
<li><input checked="" disabled="" type="checkbox"> 用于导航图标控制的返回栈监听器</li>
<li><input checked="" disabled="" type="checkbox"> 6 个占位 LabFragment 实现</li>
<li><input checked="" disabled="" type="checkbox"> 导航：列表 → 实验 → 列表</li>
<li><input checked="" disabled="" type="checkbox"> 返回箭头正确显示&#x2F;隐藏</li>
</ul>
<h3 id="手动测试步骤"><a href="#手动测试步骤" class="headerlink" title="手动测试步骤"></a>手动测试步骤</h3><ol>
<li>启动应用 → 应看到 6 个实验的列表</li>
<li>点击任意实验 → 应导航到实验页面</li>
<li>检查 Toolbar → 应显示实验标题和返回箭头</li>
<li>点击返回箭头 → 应返回列表</li>
<li>检查 Toolbar → 应显示 “PerfStabilityLab”，无箭头</li>
<li>对所有 6 个实验重复测试</li>
</ol>
<hr>
<h2 id="后续步骤（Day-3）"><a href="#后续步骤（Day-3）" class="headerlink" title="后续步骤（Day 3）"></a>后续步骤（Day 3）</h2><p>根据学习计划，Day 3 将重点：</p>
<ul>
<li><strong>统一模板</strong>: 实验的复现&#x2F;修复&#x2F;验证按钮</li>
<li><strong>屏幕日志</strong>: 可滚动的 TextView 显示实验日志</li>
<li><strong>文件日志</strong>: 追加写入 <code>filesDir/perflab_records.jsonl</code></li>
<li>将模板应用于所有 6 个实验 Fragment</li>
</ul>
<p>这将建立”证据链”工作流程：</p>
<ol>
<li><strong>复现</strong>: 演示性能问题</li>
<li><strong>证据</strong>: 捕获日志&#x2F;trace&#x2F;分析器数据</li>
<li><strong>修复</strong>: 应用优化</li>
<li><strong>验证</strong>: 通过新证据确认改进</li>
</ol>
<hr>
<h2 id="代码质量说明"><a href="#代码质量说明" class="headerlink" title="代码质量说明"></a>代码质量说明</h2><h3 id="做得好的地方"><a href="#做得好的地方" class="headerlink" title="做得好的地方"></a>做得好的地方</h3><ul>
<li>✅ 关注点分离明确（core&#x2F;ui&#x2F;home&#x2F;lab）</li>
<li>✅ 使用枚举实现类型安全导航</li>
<li>✅ 遵循 DRY 原则，使用基类 Fragment</li>
<li>✅ 正确的生命周期处理（requireContext、requireActivity）</li>
<li>✅ 现代 Android API（onBackPressedDispatcher、边到边）</li>
</ul>
<h3 id="未来改进方向"><a href="#未来改进方向" class="headerlink" title="未来改进方向"></a>未来改进方向</h3><ul>
<li>📝 考虑依赖注入管理 LabRegistry</li>
<li>📝 添加导航失败的错误处理</li>
<li>📝 实现视图绑定以实现类型安全的视图访问</li>
<li>📝 为 Fragment 过渡添加动画</li>
<li>📝 提取字符串到资源文件以支持国际化</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Day 1-2 成功建立了：</p>
<ol>
<li><strong>项目基础</strong>: 带 Fragment 导航的单 Activity 架构</li>
<li><strong>实验注册表</strong>: 集中式、类型安全的实验管理</li>
<li><strong>导航系统</strong>: 完整的路由和返回栈管理</li>
<li><strong>UI 框架</strong>: RecyclerView 列表 + 详情 Fragment</li>
<li><strong>可扩展性</strong>: 添加新实验只需最少的代码</li>
</ol>
<p>项目现在已准备好实现 Day 3 的统一模板，包括日志记录和证据收集功能。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android-Day02-RecycleView&amp;路由跳转</title>
    <url>/android/Day02-recycleview_router/</url>
    <content><![CDATA[<p>Day2 目标很明确：把“首页实验列表（RecyclerView）→ 点击进入实验页（Fragment）→ 返回回列表”这条最小导航链路跑通。你只需要做到“能跳转、能返回、Toolbar 返回箭头逻辑正确”，不需要做任何性能实验内容。</p>
<span id="more"></span>
<h1 id="按产出拆成-4-件事"><a href="#按产出拆成-4-件事" class="headerlink" title="按产出拆成 4 件事"></a>按产出拆成 4 件事</h1><h3 id="首页：RecyclerView-显示实验入口列表"><a href="#首页：RecyclerView-显示实验入口列表" class="headerlink" title="首页：RecyclerView 显示实验入口列表"></a>首页：RecyclerView 显示实验入口列表</h3><ul>
<li>做一个 LabItem 数据结构（id、标题、简介、tags 可先不做或先留空）</li>
<li>LabListFragment 展示一个 RecyclerView 列表（至少 6 项占位）：<ul>
<li>启动优化</li>
<li>卡顿&#x2F;Jank</li>
<li>泄漏</li>
<li>OOM</li>
<li>ANR</li>
<li>Crash</li>
</ul>
</li>
</ul>
<h3 id="路由：点击列表项能进入对应-LabFragment"><a href="#路由：点击列表项能进入对应-LabFragment" class="headerlink" title="路由：点击列表项能进入对应 LabFragment"></a>路由：点击列表项能进入对应 LabFragment</h3><ul>
<li>做一个 LabRegistry（注册表）：<ul>
<li>all() 返回上述 6 个 LabItem</li>
<li>createFragment(id) 返回对应的 Fragment（先是空页面&#x2F;占位页面也可以）</li>
</ul>
</li>
</ul>
<h3 id="Activity：负责切换-Fragment-back-stack"><a href="#Activity：负责切换-Fragment-back-stack" class="headerlink" title="Activity：负责切换 Fragment + back stack"></a>Activity：负责切换 Fragment + back stack</h3><ul>
<li>MainActivity.openLab(id)：<ul>
<li>replace(R.id.main_container, LabRegistry.createFragment(id))</li>
<li>addToBackStack(id)</li>
</ul>
</li>
</ul>
<h3 id="Toolbar：返回箭头显示-隐藏（Day2-的“完成标志”）"><a href="#Toolbar：返回箭头显示-隐藏（Day2-的“完成标志”）" class="headerlink" title="Toolbar：返回箭头显示&#x2F;隐藏（Day2 的“完成标志”）"></a>Toolbar：返回箭头显示&#x2F;隐藏（Day2 的“完成标志”）</h3><ul>
<li>在列表页：Toolbar 不显示返回箭头</li>
<li>进入实验页：Toolbar 显示返回箭头，点击能返回列表</li>
<li>实现方式：监听 supportFragmentManager.addOnBackStackChangedListener { … }，根据 backStack 是否为空来决定 supportActionBar?.setDisplayHomeAsUpEnabled(…)</li>
</ul>
<h1 id="RecyclerView-显示实验入口列表"><a href="#RecyclerView-显示实验入口列表" class="headerlink" title="RecyclerView 显示实验入口列表"></a>RecyclerView 显示实验入口列表</h1><h3 id="新建数据结构：LabItem"><a href="#新建数据结构：LabItem" class="headerlink" title="新建数据结构：LabItem"></a>新建数据结构：LabItem</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;nexa&#x2F;perfstabilitylab&#x2F;core&#x2F;LabItem.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.nexa.perfstabilitylab.core</span><br><span class="line"></span><br><span class="line">data class LabItem(</span><br><span class="line">    val id: String,</span><br><span class="line">    val title: String,</span><br><span class="line">    val desc: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="新建列表页布局：fragment-lab-list-xml"><a href="#新建列表页布局：fragment-lab-list-xml" class="headerlink" title="新建列表页布局：fragment_lab_list.xml"></a>新建列表页布局：fragment_lab_list.xml</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;res&#x2F;layout&#x2F;fragment_lab_list.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/rv_labs&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;16dp&quot;</span><br><span class="line">    android:clipToPadding=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure>


<h3 id="新建列表-item-布局：item-lab-xml"><a href="#新建列表-item-布局：item-lab-xml" class="headerlink" title="新建列表 item 布局：item_lab.xml"></a>新建列表 item 布局：item_lab.xml</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;res&#x2F;layout&#x2F;item_lab.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:paddingVertical=&quot;12dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_title&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;16sp&quot;</span><br><span class="line">        android:textStyle=&quot;bold&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_desc&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginTop=&quot;4dp&quot;</span><br><span class="line">        android:textSize=&quot;13sp&quot;</span><br><span class="line">        android:alpha=&quot;0.75&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>


<h3 id="新建-Adapter：LabListAdapter"><a href="#新建-Adapter：LabListAdapter" class="headerlink" title="新建 Adapter：LabListAdapter"></a>新建 Adapter：LabListAdapter</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;nexa&#x2F;perfstabilitylab&#x2F;ui&#x2F;home&#x2F;LabListAdapter.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.nexa.perfstabilitylab.ui.home</span><br><span class="line"></span><br><span class="line">import android.view.LayoutInflater</span><br><span class="line">import android.view.View</span><br><span class="line">import android.view.ViewGroup</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.recyclerview.widget.RecyclerView</span><br><span class="line">import com.nexa.perfstabilitylab.R</span><br><span class="line">import com.nexa.perfstabilitylab.core.LabItem</span><br><span class="line"></span><br><span class="line">class LabListAdapter(</span><br><span class="line">    private val items: List&lt;LabItem&gt;</span><br><span class="line">) : RecyclerView.Adapter&lt;LabListAdapter.VH&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    class VH(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">        val title: TextView = itemView.findViewById(R.id.tv_title)</span><br><span class="line">        val desc: TextView = itemView.findViewById(R.id.tv_desc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH &#123;</span><br><span class="line">        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_lab, parent, false)</span><br><span class="line">        return VH(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: VH, position: Int) &#123;</span><br><span class="line">        val item = items[position]</span><br><span class="line">        holder.title.text = item.title</span><br><span class="line">        holder.desc.text = item.desc</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount(): Int = items.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="新建-Fragment：LabListFragment"><a href="#新建-Fragment：LabListFragment" class="headerlink" title="新建 Fragment：LabListFragment"></a>新建 Fragment：LabListFragment</h3><p>新建 app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;nexa&#x2F;perfstabilitylab&#x2F;ui&#x2F;home&#x2F;LabListFragment.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.nexa.perfstabilitylab.ui.home</span><br><span class="line"></span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.view.View</span><br><span class="line">import androidx.fragment.app.Fragment</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import androidx.recyclerview.widget.RecyclerView</span><br><span class="line">import com.nexa.perfstabilitylab.R</span><br><span class="line">import com.nexa.perfstabilitylab.core.LabItem</span><br><span class="line"></span><br><span class="line">class LabListFragment : Fragment(R.layout.fragment_lab_list) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;</span><br><span class="line">        val rv = view.findViewById&lt;RecyclerView&gt;(R.id.rv_labs)</span><br><span class="line">        rv.layoutManager = LinearLayoutManager(requireContext())</span><br><span class="line"></span><br><span class="line">        val items = listOf(</span><br><span class="line">            LabItem(&quot;startup&quot;, &quot;启动优化&quot;, &quot;冷/温/热启动、初始化治理、首帧直觉&quot;),</span><br><span class="line">            LabItem(&quot;jank&quot;, &quot;卡顿 / Jank&quot;, &quot;主线程阻塞、IO、锁等待、UI/GC&quot;),</span><br><span class="line">            LabItem(&quot;leak&quot;, &quot;内存泄漏&quot;, &quot;引用链、生命周期注销&quot;),</span><br><span class="line">            LabItem(&quot;oom&quot;, &quot;OOM&quot;, &quot;峰值、Bitmap、缓存上限、降级&quot;),</span><br><span class="line">            LabItem(&quot;anr&quot;, &quot;ANR&quot;, &quot;无响应、主线程卡死/等待&quot;),</span><br><span class="line">            LabItem(&quot;crash&quot;, &quot;Crash&quot;, &quot;栈+上下文、定位与闭环&quot;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        rv.adapter = LabListAdapter(items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MainActivity-启动时显示这个列表-Fragment"><a href="#MainActivity-启动时显示这个列表-Fragment" class="headerlink" title="MainActivity 启动时显示这个列表 Fragment"></a>MainActivity 启动时显示这个列表 Fragment</h3><p>在 MainActivity.onCreate() 里（setContentView 之后）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (savedInstanceState == null) &#123;</span><br><span class="line">    supportFragmentManager.beginTransaction()</span><br><span class="line">        .replace(R.id.main_container, LabListFragment())</span><br><span class="line">        .commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>———</p>
<h2 id="Step1-完成验收"><a href="#Step1-完成验收" class="headerlink" title="Step1 完成验收"></a>Step1 完成验收</h2><ul>
<li>App 启动后看到 6 条实验入口列表。<br><img src="/images/android/Day02-recyclerview_router/01.png"></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day02-1.两数之和</title>
    <url>/algos/Day02-1.Two_Sum/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><strong>哈希表经典应用</strong>。本题是 LeetCode 第一题，核心考点是<strong>使用哈希表在一次遍历中找到目标和的两个元素</strong>，是面试必考题。</p>
<h2 id="为什么这道题重要"><a href="#为什么这道题重要" class="headerlink" title="为什么这道题重要"></a>为什么这道题重要</h2><p>这是 <strong>哈希表查找</strong>的经典应用，是 LeetCode 最受欢迎的题目，掌握后可解决：</p>
<ul>
<li><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>（本题）</li>
<li><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></li>
<li><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></li>
<li><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></li>
</ul>
<h2 id="解法对比"><a href="#解法对比" class="headerlink" title="解法对比"></a>解法对比</h2><table>
<thead>
<tr>
<th>解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>暴力枚举</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>双重循环，性能差</td>
</tr>
<tr>
<td>排序 + 双指针</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>需要修改原数组或额外空间</td>
</tr>
<tr>
<td><strong>HashMap</strong></td>
<td><strong>O(n)</strong></td>
<td><strong>O(n)</strong></td>
<td><strong>最优解，推荐背诵</strong></td>
</tr>
</tbody></table>
<p><strong>背诵重点</strong>：HashMap 解法（O(n) 时间，边遍历边查找）</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/algos/Day02-1.Two_Sum/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、哈希表</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个<strong>HashMap</strong>记录数组nums的每一个元素,key是元素，value是下标</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历nums到i的位置，HashMap的key包含[0, i-1]这个区间的元素</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>target-nums[i]在HashMap内无法找到对应的元素，nums[i]和i作为key和value放入HashMap</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li>nums循环结束也没有在HashMap中找到对应元素</li>
<li>找到对应元素</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 的长度。</li>
<li>空间复杂度：O(n)，其中 n 为 nums 的长度。</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>无</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            if (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun twoSum(nums: IntArray, target: Int): IntArray &#123;</span><br><span class="line">        val map = hashMapOf&lt;Int, Int&gt;()</span><br><span class="line">        nums.forEachIndexed &#123; i, num -&gt;</span><br><span class="line">            val complement = target - num</span><br><span class="line">            if (map.containsKey(complement)) &#123;</span><br><span class="line">                return intArrayOf(map.get(complement)!!, i)</span><br><span class="line">            &#125;</span><br><span class="line">            map[num] = i</span><br><span class="line">        &#125;</span><br><span class="line">        return intArrayOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day02-49.字母异位词分组</title>
    <url>/algos/Day02-49.Group_Anagrams/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><strong>哈希表 + 排序综合应用</strong>。本题是 LeetCode 中等难度题，核心考点是<strong>使用哈希表将排序后的字符串作为 key 进行分组</strong>，是字符串处理的经典题目。</p>
<h2 id="为什么这道题重要"><a href="#为什么这道题重要" class="headerlink" title="为什么这道题重要"></a>为什么这道题重要</h2><p>这是 <strong>哈希表分组</strong>的典型应用，掌握后可解决：</p>
<ul>
<li><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a>（本题）</li>
<li><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></li>
<li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></li>
</ul>
<h2 id="解法对比"><a href="#解法对比" class="headerlink" title="解法对比"></a>解法对比</h2><table>
<thead>
<tr>
<th>解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>暴力枚举</td>
<td>O(n² × k)</td>
<td>O(nk)</td>
<td>每组两两比较，性能差</td>
</tr>
<tr>
<td><strong>排序 + HashMap</strong></td>
<td><strong>O(nk log k)</strong></td>
<td><strong>O(nk)</strong></td>
<td><strong>最优解，推荐背诵</strong></td>
</tr>
<tr>
<td>计数 + HashMap</td>
<td>O(n(k+Σ))</td>
<td>O(n(k+Σ))</td>
<td>字符集有限时较优</td>
</tr>
</tbody></table>
<p><strong>背诵重点</strong>：排序 + HashMap 解法（通用性强）</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/algos/Day02-49.Group_Anagrams/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、哈希表、字符串、排序</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个<strong>HashMap</strong>记录strs中每个字符串排序后的结果作为key，数组作为value</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历strs到i的位置，HashMap的key包含[0, i-1]这个区间的排序好的元素，value则是存入数组</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>找到对应排序好的key，将当前元素push进数组</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li>终止：<ul>
<li>循环结束</li>
</ul>
</li>
<li>边界：<ul>
<li>单个元素</li>
<li>空数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li><p>时间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣&#x3D;26。需要遍历 n 个字符串，对于每个字符串，需要 O(k) 的时间计算每个字母出现的次数，O(∣Σ∣) 的时间生成哈希表的键，以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(n(k+∣Σ∣))。</p>
</li>
<li><p>空间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣&#x3D;26。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 O(∣Σ∣)，在渐进意义下小于 O(n(k+∣Σ∣))，可以忽略不计。</p>
</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>无</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="kotlin-排序-HashMap-解法"><a href="#kotlin-排序-HashMap-解法" class="headerlink" title="kotlin - 排序 + HashMap 解法"></a>kotlin - 排序 + HashMap 解法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun groupAnagrams(strs: Array&lt;String&gt;): List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        val map = hashMapOf&lt;String, MutableList&lt;String&gt;&gt;()</span><br><span class="line"></span><br><span class="line">        for (str:String in strs) &#123;</span><br><span class="line">            // strs每个字符串内容重新排序作为key</span><br><span class="line">            val key = str.toCharArray().sorted().joinToString(&quot;&quot;);</span><br><span class="line">            val values = map.getOrDefault(key, mutableListOf())</span><br><span class="line">            values.add(str)</span><br><span class="line">            map.put(key, values)</span><br><span class="line">        &#125;</span><br><span class="line">        return map.values.toList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-排序-HashMap-解法"><a href="#java-排序-HashMap-解法" class="headerlink" title="java - 排序 + HashMap 解法"></a>java - 排序 + HashMap 解法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (String str : strs) &#123;</span><br><span class="line">            // 将字符串字符排序作为key</span><br><span class="line">            char[] charArray = str.toCharArray();</span><br><span class="line">            Arrays.sort(charArray);</span><br><span class="line">            String key = new String(charArray);</span><br><span class="line"></span><br><span class="line">            // 获取或创建对应key的列表</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day01-217.存在重复元素</title>
    <url>/algos/Day01-217.Contains_Duplicate/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><strong>HashSet 基础应用</strong>。本题是 LeetCode 简单题，核心考点是<strong>使用 HashSet 判断数组中是否存在重复元素</strong>，是哈希表入门的第一道题。</p>
<h2 id="为什么这道题重要"><a href="#为什么这道题重要" class="headerlink" title="为什么这道题重要"></a>为什么这道题重要</h2><p>这是 <strong>哈希表去重</strong>的基础操作，掌握后可解决：</p>
<ul>
<li><a href="https://leetcode.cn/problems/contains-duplicate/">217. 存在重复元素</a>（本题）</li>
<li><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></li>
<li><a href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></li>
</ul>
<h2 id="解法对比"><a href="#解法对比" class="headerlink" title="解法对比"></a>解法对比</h2><table>
<thead>
<tr>
<th>解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>暴力枚举</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>双重循环，性能差</td>
</tr>
<tr>
<td>排序后比较</td>
<td>O(n log n)</td>
<td>O(1) 或 O(n)</td>
<td>需要修改原数组或额外空间</td>
</tr>
<tr>
<td><strong>HashSet</strong></td>
<td><strong>O(n)</strong></td>
<td><strong>O(n)</strong></td>
<td><strong>最优解，推荐背诵</strong></td>
</tr>
</tbody></table>
<p><strong>背诵重点</strong>：HashSet 解法（O(n) 时间，一次遍历）</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/algos/Day01-217.Contains_Duplicate/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>数组、哈希、排序</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个哈希seen记录已经出现过的元素。</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历到第 i 个元素时，seen 包含了前 i-1 个元素出现过的所有值</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>arr[i]没有出现在seen中</li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：当arr[i]出现在seen中。</li>
<li>边界：空数组</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>忘记将数组元素add入哈希</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Number&gt; seensSet = new HashSet&lt;Number&gt;();</span><br><span class="line">        for(int x: nums) &#123;</span><br><span class="line">            if(seensSet.contains(x)) return true;</span><br><span class="line">            seensSet.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun containsDuplicate(nums: IntArray): Boolean &#123;</span><br><span class="line">        val seensSet = HashSet&lt;Int&gt;(nums.size)</span><br><span class="line">        for(n: Int in nums) &#123;</span><br><span class="line">            if(seensSet.contains(n)) return true</span><br><span class="line">            seensSet.add(n)</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSA-Day01-242.有效的字母异位词背诵模板</title>
    <url>/algos/Day01-242.Valid_Anagram/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><strong>哈希表字符计数</strong>。本题是 LeetCode 简单题，核心考点是<strong>使用哈希表统计字符频率判断两个字符串是否为字母异位词</strong>。</p>
<h2 id="为什么这道题重要"><a href="#为什么这道题重要" class="headerlink" title="为什么这道题重要"></a>为什么这道题重要</h2><p>这是 <strong>字符统计</strong>的基础操作，掌握后可解决：</p>
<ul>
<li><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a>（本题）</li>
<li><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></li>
<li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></li>
</ul>
<h2 id="解法对比"><a href="#解法对比" class="headerlink" title="解法对比"></a>解法对比</h2><table>
<thead>
<tr>
<th>解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>排序后比较</td>
<td>O(n log n)</td>
<td>O(1) 或 O(n)</td>
<td>需要排序，代码简洁但性能较差</td>
</tr>
<tr>
<td><strong>哈希表计数</strong></td>
<td><strong>O(n)</strong></td>
<td><strong>O(Σ)</strong></td>
<td><strong>最优解，Σ 为字符集大小</strong></td>
</tr>
<tr>
<td>数组计数（限定小写字母）</td>
<td>O(n)</td>
<td>O(1)</td>
<td>仅当字符集已知时可用</td>
</tr>
</tbody></table>
<p><strong>背诵重点</strong>：哈希表计数解法（O(n) 时间）</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/algos/Day01-242.Valid_Anagram/01.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>字符串、哈希、排序</p>
<h2 id="背诵模型"><a href="#背诵模型" class="headerlink" title="背诵模型"></a>背诵模型</h2><p><strong>模型&#x2F;状态</strong></p>
<ul>
<li>我用一个<strong>HashMap</strong>记录<strong>s</strong>的所有字符出现的次数，key为字符，value为次数</li>
</ul>
<p><strong>不变量&#x2F;约束</strong></p>
<ul>
<li>遍历 <strong>s <strong>到 <strong>i <strong>的位置，<strong>i-1</strong>的字符在</strong>HashMap</strong>都作为了</strong>key</strong>，并且所有<strong>value</strong>都是<strong>大于0</strong>。</li>
</ul>
<p><strong>推进&#x2F;转移</strong></p>
<ul>
<li>循环<strong>t</strong>中的字符，找到<strong>HashMap</strong>中对应的<strong>key，<strong>如果找到则</strong>value–</strong></li>
</ul>
<p><strong>终止&#x2F;答案+边界</strong></p>
<ul>
<li>终止：<ul>
<li><strong>t</strong>和<strong>s</strong>的长度不一致</li>
<li><strong>t</strong>的字符在<strong>HashMap</strong>的<strong>key</strong>中无法找到。</li>
<li><strong>t</strong>的字符在<strong>HashMap</strong>的<strong>value</strong>在**-1<strong>之前已经为</strong>0**</li>
</ul>
</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 s 的长度。</li>
<li>空间复杂度：O(S)，其中 S 为字符集大小</li>
</ul>
<p><strong>常见坑</strong></p>
<ul>
<li>无</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line"></span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (char c: s.toCharArray()) &#123;</span><br><span class="line">            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(char c: t.toCharArray()) &#123;</span><br><span class="line">            if (!frequencyMap.containsKey(c)) return false;</span><br><span class="line">            int count = frequencyMap.get(c);</span><br><span class="line">            if (count == 0) &#123; // 若t中字符出现次数超过s，返回false</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            frequencyMap.put(c, count - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    fun isAnagram(s: String, t: String): Boolean &#123;</span><br><span class="line">        if (s.length != t.length) return false</span><br><span class="line">        </span><br><span class="line">        val frequencyMap = mutableMapOf&lt;Char, Int&gt;()</span><br><span class="line">        for (c in s) &#123;</span><br><span class="line">            frequencyMap[c] = frequencyMap.getOrDefault(c, 0) + 1</span><br><span class="line">        &#125;</span><br><span class="line">        for (c in t) &#123;</span><br><span class="line">            if (!frequencyMap.containsKey(c)) return false</span><br><span class="line">            val count = frequencyMap[c]!!  // 安全获取（因已检查存在性）</span><br><span class="line">            if (count == 0) return false</span><br><span class="line">            frequencyMap[c] = count - 1</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Android-Day01-搭建基础工程+ToolBar容器</title>
    <url>/android/Day01-skeleton_toolbar/</url>
    <content><![CDATA[<h2 id="Day01：搭建基础工程-Toolbar-容器"><a href="#Day01：搭建基础工程-Toolbar-容器" class="headerlink" title="Day01：搭建基础工程 + Toolbar 容器"></a>Day01：搭建基础工程 + Toolbar 容器</h2><p>创建 Empty Views Activity 项目，配置国内镜像加速依赖下载，搭建 Toolbar 和 Fragment 容器作为应用基础架构。</p>
<p><strong>核心内容</strong>：项目初始化、Gradle镜像配置、Toolbar集成、Fragment容器搭建</p>
<span id="more"></span>

<h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><ol>
<li>选择Empty Views Activity(<strong>重要，选择其他的可能会使用Jetpack Compose</strong>)</li>
<li>minSdk 33</li>
<li>targetSdk 36</li>
</ol>
<h1 id="镜像问题"><a href="#镜像问题" class="headerlink" title="镜像问题"></a>镜像问题</h1><h2 id="修改gradle到国内镜像"><a href="#修改gradle到国内镜像" class="headerlink" title="修改gradle到国内镜像"></a>修改gradle到国内镜像</h2><p>路径：项目根目录\gradle\wrapper\gradle-wrapper.properties</p>
<p>将原有的gradle.org修改为阿里云镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">distributionUrl=https://mirrors.aliyun.com/macports/distfiles/gradle/gradle-8.13-all.zip</span><br><span class="line">#distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-all.zip</span><br></pre></td></tr></table></figure>

<h2 id="修改插件和库依赖到国内镜像"><a href="#修改插件和库依赖到国内镜像" class="headerlink" title="修改插件和库依赖到国内镜像"></a>修改插件和库依赖到国内镜像</h2><p>插件为项目提供构建、测试、打包等能力，库提供可复用的代码&#x2F;资源</p>
<h3 id="AndroidStudio较新版本-例如-Arctic-Fox-2021-3-1-及之后"><a href="#AndroidStudio较新版本-例如-Arctic-Fox-2021-3-1-及之后" class="headerlink" title="AndroidStudio较新版本 (例如 Arctic Fox 2021.3.1 及之后)"></a>AndroidStudio较新版本 (例如 Arctic Fox 2021.3.1 及之后)</h3><ul>
<li>项目根目录存在settings.gradle,在文件当中会存在pluginManagement和 dependencyResolutionManagement代码块。</li>
</ul>
<h3 id="AndroidStudio旧版本-2021-3-1-之前"><a href="#AndroidStudio旧版本-2021-3-1-之前" class="headerlink" title="AndroidStudio旧版本 (2021.3.1 之前)"></a>AndroidStudio旧版本 (2021.3.1 之前)</h3><ul>
<li>项目根目录下的 <code>build.gradle</code>或 <code>build.gradle.kts</code></li>
<li>主要的仓库配置在根目录的 <code>build.gradle</code>文件的 <code>buildscript</code>和 <code>allprojects</code>部分。</li>
</ul>
<h3 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        // 插件新加3行</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;</span><br><span class="line">        google &#123;</span><br><span class="line">            content &#123;</span><br><span class="line">                includeGroupByRegex(&quot;com\\.android.*&quot;)</span><br><span class="line">                includeGroupByRegex(&quot;com\\.google.*&quot;)</span><br><span class="line">                includeGroupByRegex(&quot;androidx.*&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        // 库加2行</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;</span><br><span class="line">        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rootProject.name = &quot;PerfStabilityLab&quot;</span><br><span class="line">include(&quot;:app&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="搭建项目骨架"><a href="#搭建项目骨架" class="headerlink" title="搭建项目骨架"></a>搭建项目骨架</h1><h2 id="避免系统自带标题栏和ToolBar冲突"><a href="#避免系统自带标题栏和ToolBar冲突" class="headerlink" title="避免系统自带标题栏和ToolBar冲突"></a>避免系统自带标题栏和ToolBar冲突</h2><p>使用NoActionBar，res&#x2F;values&#x2F;themes.xml（或 styles.xml，看你工程生成的名字）确认类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.PerfStabilityLab&quot; parent=&quot;Theme.Material3.DayNight.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;!-- 其他颜色配置随便 --&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p> 并检查 AndroidManifest.xml 里 Application 或 Activity 使用了这个主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:theme=&quot;@style/Theme.PerfStabilityLab&quot; ... /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="在activity-main-xml修改布局"><a href="#在activity-main-xml修改布局" class="headerlink" title="在activity_main.xml修改布局"></a>在activity_main.xml修改布局</h2><p>用LinearLayout比较直观，改成上下结构，放置一个MaterialToolbar和FragmentContainerView</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;LinearLayout</span><br><span class="line">      xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">      xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">      android:orientation=&quot;vertical&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;com.google.android.material.appbar.MaterialToolbar</span><br><span class="line">          android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">          android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          app:title=&quot;PerfStabilityLab&quot; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;androidx.fragment.app.FragmentContainerView</span><br><span class="line">          android:id=&quot;@+id/main_container&quot;</span><br><span class="line">          android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;0dp&quot;</span><br><span class="line">          android:layout_weight=&quot;1&quot; /&gt;</span><br><span class="line">  &lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/android/Day01-skeleton_toolbar/01.png"></p>
<h2 id="ToolBar设置为ActionBar，放占位Fragment"><a href="#ToolBar设置为ActionBar，放占位Fragment" class="headerlink" title="ToolBar设置为ActionBar，放占位Fragment"></a>ToolBar设置为ActionBar，放占位Fragment</h2><h3 id="新建Fragment，命名为PlaceholderFragment"><a href="#新建Fragment，命名为PlaceholderFragment" class="headerlink" title="新建Fragment，命名为PlaceholderFragment"></a>新建Fragment，命名为PlaceholderFragment</h3><p>放入一个占位的TextView即可，新建Fragment的时候会自动生成PlaceholderFragment.kt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># res/layout/fragment_placeholder.xml：</span><br><span class="line"></span><br><span class="line">&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:text=&quot;Placeholder&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="MainActivity修改"><a href="#MainActivity修改" class="headerlink" title="MainActivity修改"></a>MainActivity修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        enableEdgeToEdge()</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 设置ActionBar</span><br><span class="line">        val toolBar = findViewById&lt;MaterialToolbar&gt;(R.id.toolbar)</span><br><span class="line">        setSupportActionBar(toolBar)</span><br><span class="line"></span><br><span class="line">        // 把状态栏/刘海区域的高度加到 toolbar 的 top padding</span><br><span class="line">        val initialTopPadding = toolBar.paddingTop</span><br><span class="line">        ViewCompat.setOnApplyWindowInsetsListener(toolBar) &#123; v, insets -&gt;</span><br><span class="line">            val topInset = insets.getInsets(WindowInsetsCompat.Type.statusBars()).top</span><br><span class="line">            v.updatePadding(top = initialTopPadding + topInset)</span><br><span class="line">            insets</span><br><span class="line">        &#125;</span><br><span class="line">        ViewCompat.requestApplyInsets(toolBar)</span><br><span class="line"></span><br><span class="line">        // 先设置左上角返回按钮点击事件，day2再做显示隐藏逻辑</span><br><span class="line">        toolBar.setNavigationOnClickListener &#123;</span><br><span class="line">            onBackPressedDispatcher.onBackPressed()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (savedInstanceState == null) &#123;</span><br><span class="line">            supportFragmentManager.beginTransaction()</span><br><span class="line">                .replace(R.id.main_container, PlaceholderFragment())</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行测试，确认项目骨架最小集可用"><a href="#运行测试，确认项目骨架最小集可用" class="headerlink" title="运行测试，确认项目骨架最小集可用"></a>运行测试，确认项目骨架最小集可用</h1><!-- 这是一张图片，ocr 内容为： -->
<p><img src="/images/android/Day01-skeleton_toolbar/02.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android-Day00-16周内重新复现性能学习计划</title>
    <url>/android/Day00-before_study/</url>
    <content><![CDATA[<h2 id="16周性能优化学习计划"><a href="#16周性能优化学习计划" class="headerlink" title="16周性能优化学习计划"></a>16周性能优化学习计划</h2><p>系统学习 Android 性能与稳定性优化，涵盖启动、卡顿、内存泄漏、OOM、ANR、Crash 等核心主题，通过每日90分钟的固定配方（算法+阅读+Demo+卡片输出）循序渐进掌握性能调优技能。</p>
<p><strong>每日配方</strong>：15m算法 + 45m阅读 + 25m Demo验证 + 5m卡片输出</p>
<span id="more"></span>

<h2 id="每日固定配方（90-分钟）"><a href="#每日固定配方（90-分钟）" class="headerlink" title="每日固定配方（90 分钟）"></a>每日固定配方（90 分钟）</h2><ul>
<li><strong>15m 算法</strong>：2 题（写边界 + 复杂度 + 使用模板）</li>
<li><strong>45m 阅读 + 笔记</strong>：5–10 条要点 + 1 张流程&#x2F;机制图</li>
<li><strong>25m Demo 验证</strong>：复现 → 定位 → 修复&#x2F;规避 → 再验证</li>
<li><strong>5m 输出卡片</strong>：1 张卡片（60 秒可复述）</li>
</ul>
<blockquote>
<p>第 7 天：自由（休息&#x2F;补漏&#x2F;纯复盘），不纳入日历强制安排。</p>
</blockquote>
<hr>
<h2 id="Week-1：基线与证据链"><a href="#Week-1：基线与证据链" class="headerlink" title="Week 1：基线与证据链"></a>Week 1：基线与证据链</h2><ul>
<li>D1 工程初始化</li>
<li>D2 实验列表&#x2F;路由骨架</li>
<li>D3 统一日志&#x2F;落盘记录</li>
<li>D4 Trace 打点封装 + 综合模板题</li>
<li>D5 Profiler 基础走查（CPU&#x2F;Memory）+ 错题复盘</li>
<li>D6 周复盘：证据链模板 1 页 + 补弱项</li>
</ul>
<h2 id="Week-2：Perfetto-System-Trace-入门"><a href="#Week-2：Perfetto-System-Trace-入门" class="headerlink" title="Week 2：Perfetto&#x2F;System Trace 入门"></a>Week 2：Perfetto&#x2F;System Trace 入门</h2><ul>
<li>D1 Perfetto 抓取&#x2F;界面熟悉</li>
<li>D2 Trace section 打点覆盖关键路径</li>
<li>D3 Demo：主线程阻塞 200ms（证据可见）+ 去重题</li>
<li>D4 掉帧直觉（主线程&#x2F;渲染线程）</li>
<li>D5 输出《Perfetto 最小读法清单》+ 错题复盘</li>
<li>D6 周复盘：把工具步骤固化成 checklist</li>
</ul>
<h2 id="Week-3：启动链路（冷-温-热、首帧）"><a href="#Week-3：启动链路（冷-温-热、首帧）" class="headerlink" title="Week 3：启动链路（冷&#x2F;温&#x2F;热、首帧）"></a>Week 3：启动链路（冷&#x2F;温&#x2F;热、首帧）</h2><ul>
<li>D1 启动链路概览笔记</li>
<li>D2 Demo：Application 慢初始化模拟</li>
<li>D3 Demo：延迟&#x2F;按需初始化对比 </li>
<li>D4 学 Provider&#x2F;Application 时机</li>
<li>D5 输出《启动优化要点》</li>
<li>D6 周复盘：启动证据链（现象→证据→修复→回归）</li>
</ul>
<h2 id="Week-4：初始化治理（依赖-线程安全）"><a href="#Week-4：初始化治理（依赖-线程安全）" class="headerlink" title="Week 4：初始化治理（依赖&#x2F;线程安全）"></a>Week 4：初始化治理（依赖&#x2F;线程安全）</h2><ul>
<li>D1 “越早初始化越好是错的”</li>
<li>D2 Demo：后台 init 竞态&#x2F;可见性风险 </li>
<li>D3 Demo：初始化调度（按需触发</li>
<li>D4 线程安全常见坑整理</li>
<li>D5 输出《初始化清单：必须&#x2F;可延迟&#x2F;按需》</li>
<li>D6 周复盘：固化 3 个启动相关可复现实验</li>
</ul>
<h2 id="Week-5：卡顿基础（分类：IO-锁-布局-GC）"><a href="#Week-5：卡顿基础（分类：IO-锁-布局-GC）" class="headerlink" title="Week 5：卡顿基础（分类：IO&#x2F;锁&#x2F;布局&#x2F;GC）"></a>Week 5：卡顿基础（分类：IO&#x2F;锁&#x2F;布局&#x2F;GC）</h2><ul>
<li>D1 卡顿分类笔记</li>
<li>D2 Demo：IO 卡顿复现与定位</li>
<li>D3 Demo：锁等待卡顿复现与定位</li>
<li>D4 “如何证明某段代码 &gt;16ms”</li>
<li>D5 输出《卡顿排查顺序清单》</li>
<li>D6 周复盘：卡顿证据链一份</li>
</ul>
<h2 id="Week-6：UI-性能（布局-过绘-列表）"><a href="#Week-6：UI-性能（布局-过绘-列表）" class="headerlink" title="Week 6：UI 性能（布局&#x2F;过绘&#x2F;列表）"></a>Week 6：UI 性能（布局&#x2F;过绘&#x2F;列表）</h2><ul>
<li>D1 布局性能要点</li>
<li>D2 Demo：深层级 XML vs 优化版</li>
<li>D3 Demo：RecyclerView 常见掉帧错误用法</li>
<li>D4 Layout Inspector&#x2F;渲染相关工具熟悉</li>
<li>D5 输出《UI 卡顿一页纸》+ 错题复盘</li>
<li>D6 周复盘：UI 证据链走查一遍</li>
</ul>
<h2 id="Week-7：内存与泄漏（LeakCanary-引用链）"><a href="#Week-7：内存与泄漏（LeakCanary-引用链）" class="headerlink" title="Week 7：内存与泄漏（LeakCanary&#x2F;引用链）"></a>Week 7：内存与泄漏（LeakCanary&#x2F;引用链）</h2><ul>
<li>D1 泄漏根因清单</li>
<li>D2 Demo：静态引用泄漏复现&#x2F;修复 </li>
<li>D3 Demo：监听&#x2F;回调未注销泄漏复现&#x2F;修复 </li>
<li>D4 引用链判读方法 + 数据流中位数（理解）</li>
<li>D5 输出《泄漏排查：谁持有谁》+ 错题复盘</li>
<li>D6 周复盘：沉淀 3 个泄漏模板</li>
</ul>
<h2 id="Week-8：OOM-专题（Bitmap-缓存-抖动）"><a href="#Week-8：OOM-专题（Bitmap-缓存-抖动）" class="headerlink" title="Week 8：OOM 专题（Bitmap&#x2F;缓存&#x2F;抖动）"></a>Week 8：OOM 专题（Bitmap&#x2F;缓存&#x2F;抖动）</h2><ul>
<li>D1 Bitmap&#x2F;采样&#x2F;缓存直觉</li>
<li>D2 Demo：大图&#x2F;大分配可控 OOM（谨慎）</li>
<li>D3 Demo：downsample&#x2F;上限策略对比</li>
<li>D4 内存抖动→GC→卡顿链路 </li>
<li>D5 输出《OOM 治理清单》</li>
<li>D6 周复盘：OOM 证据链一份</li>
</ul>
<h2 id="Week-9：ANR-专题（输入-广播-Service-锁）"><a href="#Week-9：ANR-专题（输入-广播-Service-锁）" class="headerlink" title="Week 9：ANR 专题（输入&#x2F;广播&#x2F;Service&#x2F;锁）"></a>Week 9：ANR 专题（输入&#x2F;广播&#x2F;Service&#x2F;锁）</h2><ul>
<li>D1 ANR 分类与超时机制</li>
<li>D2 Demo：接近 ANR 的主线程阻塞（先可控）</li>
<li>D3 Demo：锁等待型“卡死”定位 </li>
<li>D4 ANR 线程栈&#x2F;trace 的读法</li>
<li>D5 输出《ANR 排查顺序：先栈后锁再Binder》+ 错题复盘</li>
<li>D6 周复盘：ANR 证据链一份</li>
</ul>
<h2 id="Week-10：Crash-治理（日志-混淆-回滚思路）"><a href="#Week-10：Crash-治理（日志-混淆-回滚思路）" class="headerlink" title="Week 10：Crash 治理（日志&#x2F;混淆&#x2F;回滚思路）"></a>Week 10：Crash 治理（日志&#x2F;混淆&#x2F;回滚思路）</h2><ul>
<li>D1 Crash 定位流程笔记</li>
<li>D2 Demo：常见 crash 复现（NPE&#x2F;越界&#x2F;状态）</li>
<li>D3 Demo：崩溃前上下文记录（线程&#x2F;页面&#x2F;操作）</li>
<li>D4 混淆与 mapping 的意义</li>
<li>D5 输出《Crash 闭环清单》+ 错题复盘</li>
<li>D6 周复盘：Crash 证据链一份</li>
</ul>
<h2 id="Week-11：协程稳定性（取消-异常-结构化并发）"><a href="#Week-11：协程稳定性（取消-异常-结构化并发）" class="headerlink" title="Week 11：协程稳定性（取消&#x2F;异常&#x2F;结构化并发）"></a>Week 11：协程稳定性（取消&#x2F;异常&#x2F;结构化并发）</h2><ul>
<li>D1 结构化并发与取消传播 </li>
<li>D2 Demo：取消不生效&#x2F;Job 泄漏复现修复</li>
<li>D3 Demo：异常传播导致全局失败复现修复 </li>
<li>D4 Flow 冷&#x2F;热与生命周期取消直觉</li>
<li>D5 输出《协程排错清单》+ 错题复盘</li>
<li>D6 周复盘：协程事故复盘模板</li>
</ul>
<h2 id="Week-12：网络与弱网稳定性（超时-重试-幂等-降级）"><a href="#Week-12：网络与弱网稳定性（超时-重试-幂等-降级）" class="headerlink" title="Week 12：网络与弱网稳定性（超时&#x2F;重试&#x2F;幂等&#x2F;降级）"></a>Week 12：网络与弱网稳定性（超时&#x2F;重试&#x2F;幂等&#x2F;降级）</h2><ul>
<li>D1 超时&#x2F;重试&#x2F;幂等关系笔记 </li>
<li>D2 Demo：可配置超时&#x2F;重试请求模拟器 </li>
<li>D3 Demo：失败降级&#x2F;缓存兜底策略 </li>
<li>D4 缓存直觉与弱网策略 </li>
<li>D5 输出《弱网治理清单》</li>
<li>D6 周复盘：网络稳定性证据链</li>
</ul>
<h2 id="Week-13：沉淀《性能稳定性手册》"><a href="#Week-13：沉淀《性能稳定性手册》" class="headerlink" title="Week 13：沉淀《性能稳定性手册》"></a>Week 13：沉淀《性能稳定性手册》</h2><ul>
<li>D1 整理启动章节 </li>
<li>D2 整理卡顿章节</li>
<li>D3 整理泄漏&#x2F;OOM章节</li>
<li>D4 整理 ANR&#x2F;Crash&#x2F;网络章节 </li>
<li>D5 压缩成 2 页“排查路径图”</li>
<li>D6 周复盘：Demo 实验目录化&#x2F;可复用化</li>
</ul>
<h2 id="Week-14：深挖掉帧定位（渲染-帧调度直觉）"><a href="#Week-14：深挖掉帧定位（渲染-帧调度直觉）" class="headerlink" title="Week 14：深挖掉帧定位（渲染&#x2F;帧调度直觉）"></a>Week 14：深挖掉帧定位（渲染&#x2F;帧调度直觉）</h2><ul>
<li>D1 渲染&#x2F;帧调度概览 </li>
<li>D2 Demo：统计帧耗时分布（简单版）</li>
<li>D3 Demo：频繁 requestLayout&#x2F;invalidate 抖动复现 </li>
<li>D4 常见掉帧模式总结</li>
<li>D5 输出《掉帧定位证据链》</li>
<li>D6 周复盘：掉帧完整走查</li>
</ul>
<h2 id="Week-15：深挖-GC-分配与卡顿关联-补短板"><a href="#Week-15：深挖-GC-分配与卡顿关联-补短板" class="headerlink" title="Week 15：深挖 GC&#x2F;分配与卡顿关联 + 补短板"></a>Week 15：深挖 GC&#x2F;分配与卡顿关联 + 补短板</h2><ul>
<li>D1 GC 暂停直觉（不背收集器名）+ 补短板题</li>
<li>D2 Demo：频繁分配→GC→卡顿复现观察 + 补短板题</li>
<li>D3 Demo：减少分配&#x2F;复用对比验证 + 补短板题</li>
<li>D4 内存优化工程手段总结 + 补短板题</li>
<li>D5 输出《GC 卡顿：证明与缓解》+ 补短板题</li>
<li>D6 周复盘：GC 证据链一份</li>
</ul>
<h2 id="Week-16：综合闭环周（每类再跑一遍）-回顾"><a href="#Week-16：综合闭环周（每类再跑一遍）-回顾" class="headerlink" title="Week 16：综合闭环周（每类再跑一遍）+ 回顾"></a>Week 16：综合闭环周（每类再跑一遍）+ 回顾</h2><ul>
<li>D1 启动闭环 + 回顾题</li>
<li>D2 卡顿闭环 + 回顾题</li>
<li>D3 泄漏&#x2F;OOM 闭环 + 回顾题</li>
<li>D4 ANR 闭环 + 回顾题</li>
<li>D5 Crash&#x2F;网络闭环 + 回顾题</li>
<li>D6 总复盘：手册+Demo 资产清单与后续维护计划</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>DAS-DAY00-数据结构与算法必看</title>
    <url>/algos/Day00-before-studying/</url>
    <content><![CDATA[<p>更多的是对于已经对数据结构与算法有一定了解的人，可以复习，我不知道对于新手是否有帮助。</p>
<span id="more"></span>

<h2 id="针对的人群"><a href="#针对的人群" class="headerlink" title="针对的人群"></a>针对的人群</h2><p>更多的是对于已经对数据结构与算法有一定了解的人，可以复习，我不知道对于新手是否有帮助。</p>
<h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><h3 id="模型（Model-State）"><a href="#模型（Model-State）" class="headerlink" title="模型（Model &#x2F; State）"></a>模型（Model &#x2F; State）</h3><p><strong>一句话：模型&#x3D;你维护的“状态容器”是什么。</strong></p>
<p>“模型”就是你把题目抽象成的状态表示和数据结构：你打算用什么来描述当前进度&#x2F;信息。</p>
<p>例如：</p>
<ul>
<li><p>双指针题：模型 &#x3D; l&#x2F;r 指针位置（以及它们代表的区间含义）</p>
</li>
<li><p>滑动窗口：模型 &#x3D; [l,r] 窗口 + 计数表&#x2F;和等统计量</p>
</li>
<li><p>哈希判重：模型 &#x3D; seen 集合（已出现的元素集合）</p>
</li>
<li><p>BFS：模型 &#x3D; 队列中的节点 + visited&#x2F;dist</p>
</li>
<li><p>DP：模型 &#x3D; dp[i] 的定义（dp 数组含义）</p>
<hr>
</li>
</ul>
<h3 id="不变量（Invariant）"><a href="#不变量（Invariant）" class="headerlink" title="不变量（Invariant）"></a>不变量（Invariant）</h3><p>  “不变量”是指在算法执行过程中，始终保持为真的条件&#x2F;性质。它是正确性的支点。<strong>一句话：不变量&#x3D;你每一步都不破坏的“保证正确的规则”。</strong></p>
<p>  以哈希判重为例：</p>
<ul>
<li>不变量：遍历到第 i 个元素时，seen 包含了前 i-1 个元素出现过的所有值。</li>
<li>因为这个不变量成立，所以当你看到新元素 x 时：<ul>
<li>x in seen ⇒ 前面已经出现过 ⇒ 至少两次 ⇒ 可以返回 true</li>
</ul>
</li>
</ul>
<h3 id="推进（Progress-Transition）"><a href="#推进（Progress-Transition）" class="headerlink" title="推进（Progress &#x2F; Transition）"></a>推进（Progress &#x2F; Transition）</h3><p> <strong>一句话：推进&#x3D;每一步怎么更新状态，怎么缩小问题规模。</strong></p>
<p>每次循环&#x2F;递归&#x2F;迭代时，你如何：</p>
<pre><code>- 更新状态（模型）
- 让算法向结束更近（避免死循环）
- 同时保持不变量成立
</code></pre>
<p> 哈希判重的推进：</p>
<pre><code>- 读取 x
- 如果已存在：返回 true
- 否则加入 seen（更新状态）并继续遍历
</code></pre>
<p> 双指针的推进：</p>
<ul>
<li>比较后移动 l 或 r（指针前进&#x2F;收缩区间）</li>
</ul>
<h3 id="终止（Termination）"><a href="#终止（Termination）" class="headerlink" title="终止（Termination）"></a>终止（Termination）</h3><p> <strong>一句话：终止&#x3D;什么时候结束、结束时答案是什么。</strong></p>
<p>  “终止”描述两个问题：</p>
<ol>
<li>算法在什么条件下停（停止条件）</li>
<li>停的时候答案怎么取（返回什么）</li>
</ol>
<p>  哈希判重的终止：</p>
<ul>
<li><p>提前终止：发现重复立刻返回 true</p>
</li>
<li><p>正常终止：遍历完仍无重复返回 false</p>
<p>BFS 的终止：</p>
</li>
<li><p>找到目标返回最短距离</p>
</li>
<li><p>队列空说明不可达</p>
<p>把它们连起来就是你背诵时的逻辑链：<br><strong>模型（我维护什么）→ 不变量（我凭什么正确）→ 推进（我每步怎么做）→ 终止（何时停&#x2F;返回啥）</strong></p>
</li>
</ul>
<h2 id="必看路径"><a href="#必看路径" class="headerlink" title="必看路径"></a>必看路径</h2><p>参考url：<a href="https://neetcode.io/roadmap">https://neetcode.io/roadmap</a> 150题路径</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>基于Find Cpu HotSpots分析调用栈</title>
    <url>/android/basic_trace/</url>
    <content><![CDATA[<p>通过Find Cpu HotSpots分析调用栈，在对项目代码不熟悉的情况下，能帮助我们尽快定位对应的入口与触发的函数。</p>
<span id="more"></span>

<h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><h2 id="真机调试和远程屏幕准备"><a href="#真机调试和远程屏幕准备" class="headerlink" title="真机调试和远程屏幕准备"></a>真机调试和远程屏幕准备</h2><p>真机打开开发者选项和调试模式，参考这个url或自行搜索即可<a href="https://developer.android.google.cn/studio/debug/dev-options?hl=zh-cn">https://developer.android.google.cn/studio/debug/dev-options?hl=zh-cn</a></p>
<p>在github下载QtScrcpy,<a href="https://github.com/barry-ran/QtScrcpy/releases">https://github.com/barry-ran/QtScrcpy/releases</a></p>
<p>当<strong>真机打开了usb调试之后</strong>，打开QtScrcpy软件，能看到我们的真机，双击打开就可以显示屏幕，我们在电脑上远程操作真机屏幕，不用运行虚拟机，节省一些资源。</p>
<p><img src="/images/android/basic_trace/sc1.png"></p>
<p><img src="/images/android/basic_trace/sc2.png"></p>
<h2 id="官方项目准备"><a href="#官方项目准备" class="headerlink" title="官方项目准备"></a>官方项目准备</h2><p>这里以官方的示例项目的jetnews作为我们的演示项目<a href="https://github.com/android/compose-samples">https://github.com/android/compose-samples</a></p>
<h3 id="gradle镜像配置"><a href="#gradle镜像配置" class="headerlink" title="gradle镜像配置"></a>gradle镜像配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// jetnews/gradle/wrapper/gradle-wrapper.properties</span><br><span class="line">// 修改为aliyun镜像，并且gradle-8.13-bin.zip可以修改为gradle-8.13-all.zip</span><br><span class="line">distributionUrl=https\://mirrors.aliyun.com/macports/distfiles/gradle/gradle-8.13-all.zip</span><br></pre></td></tr></table></figure>

<h3 id="插件镜像"><a href="#插件镜像" class="headerlink" title="插件镜像"></a>插件镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// jetnews/setting.gradle.kts</span><br><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url=uri (&quot;https://www.jitpack.io&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/releases&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/google&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/central&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/public&quot;)&#125;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        snapshotVersion?.let &#123;</span><br><span class="line">            println(&quot;https://androidx.dev/snapshots/builds/$it/artifacts/repository/&quot;)</span><br><span class="line">            maven &#123; url = uri(&quot;https://androidx.dev/snapshots/builds/$it/artifacts/repository/&quot;) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://www.jitpack.io&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/releases&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/google&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/central&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;)&#125;</span><br><span class="line">        maven &#123; url=uri (&quot;https://maven.aliyun.com/repository/public&quot;)&#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装app到真机"><a href="#安装app到真机" class="headerlink" title="安装app到真机"></a>安装app到真机</h3><p><img src="/images/android/basic_trace/sc3.png"></p>
<h1 id="录制trace文件"><a href="#录制trace文件" class="headerlink" title="录制trace文件"></a>录制trace文件</h1><p>先打开profile，不然看不到录制入口<br><img src="/images/android/basic_trace/sc4.png"></p>
<p>选择进程，Find Cpu Spots, 开始录制<br><img src="/images/android/basic_trace/sc5.png"></p>
<p>开始录制后根据要求操作屏幕，可以是点击跳转，滑动等，操作完屏幕点击停止录制，会生成trace文件，我们可以导出trace文件</p>
<p><img src="/images/android/basic_trace/sc6.png"></p>
<h1 id="分析trace文件"><a href="#分析trace文件" class="headerlink" title="分析trace文件"></a>分析trace文件</h1><p>打开这个url <a href="https://profiler.firefox.com/%EF%BC%8C%E5%B0%86trace%E6%96%87%E4%BB%B6%E6%8B%96%E5%85%A5%E7%BD%91%E9%A1%B5">https://profiler.firefox.com/，将trace文件拖入网页</a></p>
<p>因为app运行在主线程，点击main和栈图，筛选输入click，查看绿色部分，可以发现点击的时候，触发了一堆包下的方法，那么知道了这些包名和方法，就可以通过全局搜索查到对应的入口了</p>
<p><img src="/images/android/basic_trace/sc7.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>I&#39;m back</title>
    <url>/something/imback/</url>
    <content><![CDATA[<p>在今天开始，网站重新部署了，一切正在往好的方向发展，26年加油~~~~~</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
</search>
